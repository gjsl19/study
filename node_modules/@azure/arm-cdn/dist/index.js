'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given a result page from a pageable operation, returns a
 * continuation token that can be used to begin paging from
 * that point later.
 * @param page A result object from calling .byPage() on a paged operation.
 * @returns The continuation token that can be passed into byPage().
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ResourceType} that the service accepts. */
exports.KnownResourceType = void 0;
(function (KnownResourceType) {
    /** MicrosoftCdnProfilesEndpoints */
    KnownResourceType["MicrosoftCdnProfilesEndpoints"] = "Microsoft.Cdn/Profiles/Endpoints";
    /** MicrosoftCdnProfilesAfdEndpoints */
    KnownResourceType["MicrosoftCdnProfilesAfdEndpoints"] = "Microsoft.Cdn/Profiles/AfdEndpoints";
})(exports.KnownResourceType || (exports.KnownResourceType = {}));
/** Known values of {@link AutoGeneratedDomainNameLabelScope} that the service accepts. */
exports.KnownAutoGeneratedDomainNameLabelScope = void 0;
(function (KnownAutoGeneratedDomainNameLabelScope) {
    /** TenantReuse */
    KnownAutoGeneratedDomainNameLabelScope["TenantReuse"] = "TenantReuse";
    /** SubscriptionReuse */
    KnownAutoGeneratedDomainNameLabelScope["SubscriptionReuse"] = "SubscriptionReuse";
    /** ResourceGroupReuse */
    KnownAutoGeneratedDomainNameLabelScope["ResourceGroupReuse"] = "ResourceGroupReuse";
    /** NoReuse */
    KnownAutoGeneratedDomainNameLabelScope["NoReuse"] = "NoReuse";
})(exports.KnownAutoGeneratedDomainNameLabelScope || (exports.KnownAutoGeneratedDomainNameLabelScope = {}));
/** Known values of {@link UsageUnit} that the service accepts. */
exports.KnownUsageUnit = void 0;
(function (KnownUsageUnit) {
    /** Count */
    KnownUsageUnit["Count"] = "Count";
})(exports.KnownUsageUnit || (exports.KnownUsageUnit = {}));
/** Known values of {@link DomainValidationState} that the service accepts. */
exports.KnownDomainValidationState = void 0;
(function (KnownDomainValidationState) {
    /** Unknown */
    KnownDomainValidationState["Unknown"] = "Unknown";
    /** Submitting */
    KnownDomainValidationState["Submitting"] = "Submitting";
    /** Pending */
    KnownDomainValidationState["Pending"] = "Pending";
    /** Rejected */
    KnownDomainValidationState["Rejected"] = "Rejected";
    /** TimedOut */
    KnownDomainValidationState["TimedOut"] = "TimedOut";
    /** PendingRevalidation */
    KnownDomainValidationState["PendingRevalidation"] = "PendingRevalidation";
    /** Approved */
    KnownDomainValidationState["Approved"] = "Approved";
    /** RefreshingValidationToken */
    KnownDomainValidationState["RefreshingValidationToken"] = "RefreshingValidationToken";
    /** InternalError */
    KnownDomainValidationState["InternalError"] = "InternalError";
})(exports.KnownDomainValidationState || (exports.KnownDomainValidationState = {}));
/** Known values of {@link AfdCertificateType} that the service accepts. */
exports.KnownAfdCertificateType = void 0;
(function (KnownAfdCertificateType) {
    /** CustomerCertificate */
    KnownAfdCertificateType["CustomerCertificate"] = "CustomerCertificate";
    /** ManagedCertificate */
    KnownAfdCertificateType["ManagedCertificate"] = "ManagedCertificate";
    /** AzureFirstPartyManagedCertificate */
    KnownAfdCertificateType["AzureFirstPartyManagedCertificate"] = "AzureFirstPartyManagedCertificate";
})(exports.KnownAfdCertificateType || (exports.KnownAfdCertificateType = {}));
/** Known values of {@link AfdProvisioningState} that the service accepts. */
exports.KnownAfdProvisioningState = void 0;
(function (KnownAfdProvisioningState) {
    /** Succeeded */
    KnownAfdProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownAfdProvisioningState["Failed"] = "Failed";
    /** Updating */
    KnownAfdProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownAfdProvisioningState["Deleting"] = "Deleting";
    /** Creating */
    KnownAfdProvisioningState["Creating"] = "Creating";
})(exports.KnownAfdProvisioningState || (exports.KnownAfdProvisioningState = {}));
/** Known values of {@link DeploymentStatus} that the service accepts. */
exports.KnownDeploymentStatus = void 0;
(function (KnownDeploymentStatus) {
    /** NotStarted */
    KnownDeploymentStatus["NotStarted"] = "NotStarted";
    /** InProgress */
    KnownDeploymentStatus["InProgress"] = "InProgress";
    /** Succeeded */
    KnownDeploymentStatus["Succeeded"] = "Succeeded";
    /** Failed */
    KnownDeploymentStatus["Failed"] = "Failed";
})(exports.KnownDeploymentStatus || (exports.KnownDeploymentStatus = {}));
/** Known values of {@link IdentityType} that the service accepts. */
exports.KnownIdentityType = void 0;
(function (KnownIdentityType) {
    /** User */
    KnownIdentityType["User"] = "user";
    /** Application */
    KnownIdentityType["Application"] = "application";
    /** ManagedIdentity */
    KnownIdentityType["ManagedIdentity"] = "managedIdentity";
    /** Key */
    KnownIdentityType["Key"] = "key";
})(exports.KnownIdentityType || (exports.KnownIdentityType = {}));
/** Known values of {@link EnabledState} that the service accepts. */
exports.KnownEnabledState = void 0;
(function (KnownEnabledState) {
    /** Enabled */
    KnownEnabledState["Enabled"] = "Enabled";
    /** Disabled */
    KnownEnabledState["Disabled"] = "Disabled";
})(exports.KnownEnabledState || (exports.KnownEnabledState = {}));
/** Known values of {@link AFDEndpointProtocols} that the service accepts. */
exports.KnownAFDEndpointProtocols = void 0;
(function (KnownAFDEndpointProtocols) {
    /** Http */
    KnownAFDEndpointProtocols["Http"] = "Http";
    /** Https */
    KnownAFDEndpointProtocols["Https"] = "Https";
})(exports.KnownAFDEndpointProtocols || (exports.KnownAFDEndpointProtocols = {}));
/** Known values of {@link AfdQueryStringCachingBehavior} that the service accepts. */
exports.KnownAfdQueryStringCachingBehavior = void 0;
(function (KnownAfdQueryStringCachingBehavior) {
    /** IgnoreQueryString */
    KnownAfdQueryStringCachingBehavior["IgnoreQueryString"] = "IgnoreQueryString";
    /** UseQueryString */
    KnownAfdQueryStringCachingBehavior["UseQueryString"] = "UseQueryString";
    /** IgnoreSpecifiedQueryStrings */
    KnownAfdQueryStringCachingBehavior["IgnoreSpecifiedQueryStrings"] = "IgnoreSpecifiedQueryStrings";
    /** IncludeSpecifiedQueryStrings */
    KnownAfdQueryStringCachingBehavior["IncludeSpecifiedQueryStrings"] = "IncludeSpecifiedQueryStrings";
})(exports.KnownAfdQueryStringCachingBehavior || (exports.KnownAfdQueryStringCachingBehavior = {}));
/** Known values of {@link ForwardingProtocol} that the service accepts. */
exports.KnownForwardingProtocol = void 0;
(function (KnownForwardingProtocol) {
    /** HttpOnly */
    KnownForwardingProtocol["HttpOnly"] = "HttpOnly";
    /** HttpsOnly */
    KnownForwardingProtocol["HttpsOnly"] = "HttpsOnly";
    /** MatchRequest */
    KnownForwardingProtocol["MatchRequest"] = "MatchRequest";
})(exports.KnownForwardingProtocol || (exports.KnownForwardingProtocol = {}));
/** Known values of {@link LinkToDefaultDomain} that the service accepts. */
exports.KnownLinkToDefaultDomain = void 0;
(function (KnownLinkToDefaultDomain) {
    /** Enabled */
    KnownLinkToDefaultDomain["Enabled"] = "Enabled";
    /** Disabled */
    KnownLinkToDefaultDomain["Disabled"] = "Disabled";
})(exports.KnownLinkToDefaultDomain || (exports.KnownLinkToDefaultDomain = {}));
/** Known values of {@link HttpsRedirect} that the service accepts. */
exports.KnownHttpsRedirect = void 0;
(function (KnownHttpsRedirect) {
    /** Enabled */
    KnownHttpsRedirect["Enabled"] = "Enabled";
    /** Disabled */
    KnownHttpsRedirect["Disabled"] = "Disabled";
})(exports.KnownHttpsRedirect || (exports.KnownHttpsRedirect = {}));
/** Known values of {@link MatchVariable} that the service accepts. */
exports.KnownMatchVariable = void 0;
(function (KnownMatchVariable) {
    /** RemoteAddress */
    KnownMatchVariable["RemoteAddress"] = "RemoteAddress";
    /** RequestMethod */
    KnownMatchVariable["RequestMethod"] = "RequestMethod";
    /** QueryString */
    KnownMatchVariable["QueryString"] = "QueryString";
    /** PostArgs */
    KnownMatchVariable["PostArgs"] = "PostArgs";
    /** RequestUri */
    KnownMatchVariable["RequestUri"] = "RequestUri";
    /** RequestHeader */
    KnownMatchVariable["RequestHeader"] = "RequestHeader";
    /** RequestBody */
    KnownMatchVariable["RequestBody"] = "RequestBody";
    /** RequestScheme */
    KnownMatchVariable["RequestScheme"] = "RequestScheme";
    /** UrlPath */
    KnownMatchVariable["UrlPath"] = "UrlPath";
    /** UrlFileExtension */
    KnownMatchVariable["UrlFileExtension"] = "UrlFileExtension";
    /** UrlFileName */
    KnownMatchVariable["UrlFileName"] = "UrlFileName";
    /** HttpVersion */
    KnownMatchVariable["HttpVersion"] = "HttpVersion";
    /** Cookies */
    KnownMatchVariable["Cookies"] = "Cookies";
    /** IsDevice */
    KnownMatchVariable["IsDevice"] = "IsDevice";
    /** SocketAddr */
    KnownMatchVariable["SocketAddr"] = "SocketAddr";
    /** ClientPort */
    KnownMatchVariable["ClientPort"] = "ClientPort";
    /** ServerPort */
    KnownMatchVariable["ServerPort"] = "ServerPort";
    /** HostName */
    KnownMatchVariable["HostName"] = "HostName";
    /** SslProtocol */
    KnownMatchVariable["SslProtocol"] = "SslProtocol";
})(exports.KnownMatchVariable || (exports.KnownMatchVariable = {}));
/** Known values of {@link DeliveryRuleAction} that the service accepts. */
exports.KnownDeliveryRuleAction = void 0;
(function (KnownDeliveryRuleAction) {
    /** CacheExpiration */
    KnownDeliveryRuleAction["CacheExpiration"] = "CacheExpiration";
    /** CacheKeyQueryString */
    KnownDeliveryRuleAction["CacheKeyQueryString"] = "CacheKeyQueryString";
    /** ModifyRequestHeader */
    KnownDeliveryRuleAction["ModifyRequestHeader"] = "ModifyRequestHeader";
    /** ModifyResponseHeader */
    KnownDeliveryRuleAction["ModifyResponseHeader"] = "ModifyResponseHeader";
    /** UrlRedirect */
    KnownDeliveryRuleAction["UrlRedirect"] = "UrlRedirect";
    /** UrlRewrite */
    KnownDeliveryRuleAction["UrlRewrite"] = "UrlRewrite";
    /** UrlSigning */
    KnownDeliveryRuleAction["UrlSigning"] = "UrlSigning";
    /** OriginGroupOverride */
    KnownDeliveryRuleAction["OriginGroupOverride"] = "OriginGroupOverride";
    /** RouteConfigurationOverride */
    KnownDeliveryRuleAction["RouteConfigurationOverride"] = "RouteConfigurationOverride";
})(exports.KnownDeliveryRuleAction || (exports.KnownDeliveryRuleAction = {}));
/** Known values of {@link MatchProcessingBehavior} that the service accepts. */
exports.KnownMatchProcessingBehavior = void 0;
(function (KnownMatchProcessingBehavior) {
    /** Continue */
    KnownMatchProcessingBehavior["Continue"] = "Continue";
    /** Stop */
    KnownMatchProcessingBehavior["Stop"] = "Stop";
})(exports.KnownMatchProcessingBehavior || (exports.KnownMatchProcessingBehavior = {}));
/** Known values of {@link SecurityPolicyType} that the service accepts. */
exports.KnownSecurityPolicyType = void 0;
(function (KnownSecurityPolicyType) {
    /** WebApplicationFirewall */
    KnownSecurityPolicyType["WebApplicationFirewall"] = "WebApplicationFirewall";
})(exports.KnownSecurityPolicyType || (exports.KnownSecurityPolicyType = {}));
/** Known values of {@link SecretType} that the service accepts. */
exports.KnownSecretType = void 0;
(function (KnownSecretType) {
    /** UrlSigningKey */
    KnownSecretType["UrlSigningKey"] = "UrlSigningKey";
    /** CustomerCertificate */
    KnownSecretType["CustomerCertificate"] = "CustomerCertificate";
    /** ManagedCertificate */
    KnownSecretType["ManagedCertificate"] = "ManagedCertificate";
    /** AzureFirstPartyManagedCertificate */
    KnownSecretType["AzureFirstPartyManagedCertificate"] = "AzureFirstPartyManagedCertificate";
})(exports.KnownSecretType || (exports.KnownSecretType = {}));
/** Known values of {@link Status} that the service accepts. */
exports.KnownStatus = void 0;
(function (KnownStatus) {
    /** Valid */
    KnownStatus["Valid"] = "Valid";
    /** Invalid */
    KnownStatus["Invalid"] = "Invalid";
    /** AccessDenied */
    KnownStatus["AccessDenied"] = "AccessDenied";
    /** CertificateExpired */
    KnownStatus["CertificateExpired"] = "CertificateExpired";
})(exports.KnownStatus || (exports.KnownStatus = {}));
/** Known values of {@link LogMetric} that the service accepts. */
exports.KnownLogMetric = void 0;
(function (KnownLogMetric) {
    /** ClientRequestCount */
    KnownLogMetric["ClientRequestCount"] = "clientRequestCount";
    /** ClientRequestTraffic */
    KnownLogMetric["ClientRequestTraffic"] = "clientRequestTraffic";
    /** ClientRequestBandwidth */
    KnownLogMetric["ClientRequestBandwidth"] = "clientRequestBandwidth";
    /** OriginRequestTraffic */
    KnownLogMetric["OriginRequestTraffic"] = "originRequestTraffic";
    /** OriginRequestBandwidth */
    KnownLogMetric["OriginRequestBandwidth"] = "originRequestBandwidth";
    /** TotalLatency */
    KnownLogMetric["TotalLatency"] = "totalLatency";
})(exports.KnownLogMetric || (exports.KnownLogMetric = {}));
/** Known values of {@link LogMetricsGranularity} that the service accepts. */
exports.KnownLogMetricsGranularity = void 0;
(function (KnownLogMetricsGranularity) {
    /** PT5M */
    KnownLogMetricsGranularity["PT5M"] = "PT5M";
    /** PT1H */
    KnownLogMetricsGranularity["PT1H"] = "PT1H";
    /** P1D */
    KnownLogMetricsGranularity["P1D"] = "P1D";
})(exports.KnownLogMetricsGranularity || (exports.KnownLogMetricsGranularity = {}));
/** Known values of {@link LogMetricsGroupBy} that the service accepts. */
exports.KnownLogMetricsGroupBy = void 0;
(function (KnownLogMetricsGroupBy) {
    /** HttpStatusCode */
    KnownLogMetricsGroupBy["HttpStatusCode"] = "httpStatusCode";
    /** Protocol */
    KnownLogMetricsGroupBy["Protocol"] = "protocol";
    /** CacheStatus */
    KnownLogMetricsGroupBy["CacheStatus"] = "cacheStatus";
    /** CountryOrRegion */
    KnownLogMetricsGroupBy["CountryOrRegion"] = "countryOrRegion";
    /** CustomDomain */
    KnownLogMetricsGroupBy["CustomDomain"] = "customDomain";
})(exports.KnownLogMetricsGroupBy || (exports.KnownLogMetricsGroupBy = {}));
/** Known values of {@link MetricsResponseGranularity} that the service accepts. */
exports.KnownMetricsResponseGranularity = void 0;
(function (KnownMetricsResponseGranularity) {
    /** PT5M */
    KnownMetricsResponseGranularity["PT5M"] = "PT5M";
    /** PT1H */
    KnownMetricsResponseGranularity["PT1H"] = "PT1H";
    /** P1D */
    KnownMetricsResponseGranularity["P1D"] = "P1D";
})(exports.KnownMetricsResponseGranularity || (exports.KnownMetricsResponseGranularity = {}));
/** Known values of {@link MetricsResponseSeriesItemUnit} that the service accepts. */
exports.KnownMetricsResponseSeriesItemUnit = void 0;
(function (KnownMetricsResponseSeriesItemUnit) {
    /** Count */
    KnownMetricsResponseSeriesItemUnit["Count"] = "count";
    /** Bytes */
    KnownMetricsResponseSeriesItemUnit["Bytes"] = "bytes";
    /** BitsPerSecond */
    KnownMetricsResponseSeriesItemUnit["BitsPerSecond"] = "bitsPerSecond";
    /** MilliSeconds */
    KnownMetricsResponseSeriesItemUnit["MilliSeconds"] = "milliSeconds";
})(exports.KnownMetricsResponseSeriesItemUnit || (exports.KnownMetricsResponseSeriesItemUnit = {}));
/** Known values of {@link LogRanking} that the service accepts. */
exports.KnownLogRanking = void 0;
(function (KnownLogRanking) {
    /** Url */
    KnownLogRanking["Url"] = "url";
    /** Referrer */
    KnownLogRanking["Referrer"] = "referrer";
    /** Browser */
    KnownLogRanking["Browser"] = "browser";
    /** UserAgent */
    KnownLogRanking["UserAgent"] = "userAgent";
    /** CountryOrRegion */
    KnownLogRanking["CountryOrRegion"] = "countryOrRegion";
})(exports.KnownLogRanking || (exports.KnownLogRanking = {}));
/** Known values of {@link LogRankingMetric} that the service accepts. */
exports.KnownLogRankingMetric = void 0;
(function (KnownLogRankingMetric) {
    /** ClientRequestCount */
    KnownLogRankingMetric["ClientRequestCount"] = "clientRequestCount";
    /** ClientRequestTraffic */
    KnownLogRankingMetric["ClientRequestTraffic"] = "clientRequestTraffic";
    /** HitCount */
    KnownLogRankingMetric["HitCount"] = "hitCount";
    /** MissCount */
    KnownLogRankingMetric["MissCount"] = "missCount";
    /** UserErrorCount */
    KnownLogRankingMetric["UserErrorCount"] = "userErrorCount";
    /** ErrorCount */
    KnownLogRankingMetric["ErrorCount"] = "errorCount";
})(exports.KnownLogRankingMetric || (exports.KnownLogRankingMetric = {}));
/** Known values of {@link WafMetric} that the service accepts. */
exports.KnownWafMetric = void 0;
(function (KnownWafMetric) {
    /** ClientRequestCount */
    KnownWafMetric["ClientRequestCount"] = "clientRequestCount";
})(exports.KnownWafMetric || (exports.KnownWafMetric = {}));
/** Known values of {@link WafGranularity} that the service accepts. */
exports.KnownWafGranularity = void 0;
(function (KnownWafGranularity) {
    /** PT5M */
    KnownWafGranularity["PT5M"] = "PT5M";
    /** PT1H */
    KnownWafGranularity["PT1H"] = "PT1H";
    /** P1D */
    KnownWafGranularity["P1D"] = "P1D";
})(exports.KnownWafGranularity || (exports.KnownWafGranularity = {}));
/** Known values of {@link WafAction} that the service accepts. */
exports.KnownWafAction = void 0;
(function (KnownWafAction) {
    /** Allow */
    KnownWafAction["Allow"] = "allow";
    /** Block */
    KnownWafAction["Block"] = "block";
    /** Log */
    KnownWafAction["Log"] = "log";
    /** Redirect */
    KnownWafAction["Redirect"] = "redirect";
})(exports.KnownWafAction || (exports.KnownWafAction = {}));
/** Known values of {@link WafRankingGroupBy} that the service accepts. */
exports.KnownWafRankingGroupBy = void 0;
(function (KnownWafRankingGroupBy) {
    /** HttpStatusCode */
    KnownWafRankingGroupBy["HttpStatusCode"] = "httpStatusCode";
    /** CustomDomain */
    KnownWafRankingGroupBy["CustomDomain"] = "customDomain";
})(exports.KnownWafRankingGroupBy || (exports.KnownWafRankingGroupBy = {}));
/** Known values of {@link WafRuleType} that the service accepts. */
exports.KnownWafRuleType = void 0;
(function (KnownWafRuleType) {
    /** Managed */
    KnownWafRuleType["Managed"] = "managed";
    /** Custom */
    KnownWafRuleType["Custom"] = "custom";
    /** Bot */
    KnownWafRuleType["Bot"] = "bot";
})(exports.KnownWafRuleType || (exports.KnownWafRuleType = {}));
/** Known values of {@link WafMetricsResponseGranularity} that the service accepts. */
exports.KnownWafMetricsResponseGranularity = void 0;
(function (KnownWafMetricsResponseGranularity) {
    /** PT5M */
    KnownWafMetricsResponseGranularity["PT5M"] = "PT5M";
    /** PT1H */
    KnownWafMetricsResponseGranularity["PT1H"] = "PT1H";
    /** P1D */
    KnownWafMetricsResponseGranularity["P1D"] = "P1D";
})(exports.KnownWafMetricsResponseGranularity || (exports.KnownWafMetricsResponseGranularity = {}));
/** Known values of {@link WafRankingType} that the service accepts. */
exports.KnownWafRankingType = void 0;
(function (KnownWafRankingType) {
    /** Action */
    KnownWafRankingType["Action"] = "action";
    /** RuleGroup */
    KnownWafRankingType["RuleGroup"] = "ruleGroup";
    /** RuleId */
    KnownWafRankingType["RuleId"] = "ruleId";
    /** UserAgent */
    KnownWafRankingType["UserAgent"] = "userAgent";
    /** ClientIp */
    KnownWafRankingType["ClientIp"] = "clientIp";
    /** Url */
    KnownWafRankingType["Url"] = "url";
    /** CountryOrRegion */
    KnownWafRankingType["CountryOrRegion"] = "countryOrRegion";
    /** RuleType */
    KnownWafRankingType["RuleType"] = "ruleType";
})(exports.KnownWafRankingType || (exports.KnownWafRankingType = {}));
/** Known values of {@link SkuName} that the service accepts. */
exports.KnownSkuName = void 0;
(function (KnownSkuName) {
    /** StandardVerizon */
    KnownSkuName["StandardVerizon"] = "Standard_Verizon";
    /** PremiumVerizon */
    KnownSkuName["PremiumVerizon"] = "Premium_Verizon";
    /** CustomVerizon */
    KnownSkuName["CustomVerizon"] = "Custom_Verizon";
    /** StandardAkamai */
    KnownSkuName["StandardAkamai"] = "Standard_Akamai";
    /** StandardChinaCdn */
    KnownSkuName["StandardChinaCdn"] = "Standard_ChinaCdn";
    /** StandardMicrosoft */
    KnownSkuName["StandardMicrosoft"] = "Standard_Microsoft";
    /** StandardAzureFrontDoor */
    KnownSkuName["StandardAzureFrontDoor"] = "Standard_AzureFrontDoor";
    /** PremiumAzureFrontDoor */
    KnownSkuName["PremiumAzureFrontDoor"] = "Premium_AzureFrontDoor";
    /** Standard955BandWidthChinaCdn */
    KnownSkuName["Standard955BandWidthChinaCdn"] = "Standard_955BandWidth_ChinaCdn";
    /** StandardAvgBandWidthChinaCdn */
    KnownSkuName["StandardAvgBandWidthChinaCdn"] = "Standard_AvgBandWidth_ChinaCdn";
    /** StandardPlusChinaCdn */
    KnownSkuName["StandardPlusChinaCdn"] = "StandardPlus_ChinaCdn";
    /** StandardPlus955BandWidthChinaCdn */
    KnownSkuName["StandardPlus955BandWidthChinaCdn"] = "StandardPlus_955BandWidth_ChinaCdn";
    /** StandardPlusAvgBandWidthChinaCdn */
    KnownSkuName["StandardPlusAvgBandWidthChinaCdn"] = "StandardPlus_AvgBandWidth_ChinaCdn";
})(exports.KnownSkuName || (exports.KnownSkuName = {}));
/** Known values of {@link ProfileResourceState} that the service accepts. */
exports.KnownProfileResourceState = void 0;
(function (KnownProfileResourceState) {
    /** Creating */
    KnownProfileResourceState["Creating"] = "Creating";
    /** Active */
    KnownProfileResourceState["Active"] = "Active";
    /** Deleting */
    KnownProfileResourceState["Deleting"] = "Deleting";
    /** Disabled */
    KnownProfileResourceState["Disabled"] = "Disabled";
})(exports.KnownProfileResourceState || (exports.KnownProfileResourceState = {}));
/** Known values of {@link ProfileProvisioningState} that the service accepts. */
exports.KnownProfileProvisioningState = void 0;
(function (KnownProfileProvisioningState) {
    /** Succeeded */
    KnownProfileProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownProfileProvisioningState["Failed"] = "Failed";
    /** Updating */
    KnownProfileProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownProfileProvisioningState["Deleting"] = "Deleting";
    /** Creating */
    KnownProfileProvisioningState["Creating"] = "Creating";
})(exports.KnownProfileProvisioningState || (exports.KnownProfileProvisioningState = {}));
/** Known values of {@link OptimizationType} that the service accepts. */
exports.KnownOptimizationType = void 0;
(function (KnownOptimizationType) {
    /** GeneralWebDelivery */
    KnownOptimizationType["GeneralWebDelivery"] = "GeneralWebDelivery";
    /** GeneralMediaStreaming */
    KnownOptimizationType["GeneralMediaStreaming"] = "GeneralMediaStreaming";
    /** VideoOnDemandMediaStreaming */
    KnownOptimizationType["VideoOnDemandMediaStreaming"] = "VideoOnDemandMediaStreaming";
    /** LargeFileDownload */
    KnownOptimizationType["LargeFileDownload"] = "LargeFileDownload";
    /** DynamicSiteAcceleration */
    KnownOptimizationType["DynamicSiteAcceleration"] = "DynamicSiteAcceleration";
})(exports.KnownOptimizationType || (exports.KnownOptimizationType = {}));
/** Known values of {@link ResourceUsageUnit} that the service accepts. */
exports.KnownResourceUsageUnit = void 0;
(function (KnownResourceUsageUnit) {
    /** Count */
    KnownResourceUsageUnit["Count"] = "count";
})(exports.KnownResourceUsageUnit || (exports.KnownResourceUsageUnit = {}));
/** Known values of {@link PrivateEndpointStatus} that the service accepts. */
exports.KnownPrivateEndpointStatus = void 0;
(function (KnownPrivateEndpointStatus) {
    /** Pending */
    KnownPrivateEndpointStatus["Pending"] = "Pending";
    /** Approved */
    KnownPrivateEndpointStatus["Approved"] = "Approved";
    /** Rejected */
    KnownPrivateEndpointStatus["Rejected"] = "Rejected";
    /** Disconnected */
    KnownPrivateEndpointStatus["Disconnected"] = "Disconnected";
    /** Timeout */
    KnownPrivateEndpointStatus["Timeout"] = "Timeout";
})(exports.KnownPrivateEndpointStatus || (exports.KnownPrivateEndpointStatus = {}));
/** Known values of {@link EndpointResourceState} that the service accepts. */
exports.KnownEndpointResourceState = void 0;
(function (KnownEndpointResourceState) {
    /** Creating */
    KnownEndpointResourceState["Creating"] = "Creating";
    /** Deleting */
    KnownEndpointResourceState["Deleting"] = "Deleting";
    /** Running */
    KnownEndpointResourceState["Running"] = "Running";
    /** Starting */
    KnownEndpointResourceState["Starting"] = "Starting";
    /** Stopped */
    KnownEndpointResourceState["Stopped"] = "Stopped";
    /** Stopping */
    KnownEndpointResourceState["Stopping"] = "Stopping";
})(exports.KnownEndpointResourceState || (exports.KnownEndpointResourceState = {}));
/** Known values of {@link EndpointProvisioningState} that the service accepts. */
exports.KnownEndpointProvisioningState = void 0;
(function (KnownEndpointProvisioningState) {
    /** Succeeded */
    KnownEndpointProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownEndpointProvisioningState["Failed"] = "Failed";
    /** Updating */
    KnownEndpointProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownEndpointProvisioningState["Deleting"] = "Deleting";
    /** Creating */
    KnownEndpointProvisioningState["Creating"] = "Creating";
})(exports.KnownEndpointProvisioningState || (exports.KnownEndpointProvisioningState = {}));
/** Known values of {@link OriginResourceState} that the service accepts. */
exports.KnownOriginResourceState = void 0;
(function (KnownOriginResourceState) {
    /** Creating */
    KnownOriginResourceState["Creating"] = "Creating";
    /** Active */
    KnownOriginResourceState["Active"] = "Active";
    /** Deleting */
    KnownOriginResourceState["Deleting"] = "Deleting";
})(exports.KnownOriginResourceState || (exports.KnownOriginResourceState = {}));
/** Known values of {@link OriginProvisioningState} that the service accepts. */
exports.KnownOriginProvisioningState = void 0;
(function (KnownOriginProvisioningState) {
    /** Succeeded */
    KnownOriginProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownOriginProvisioningState["Failed"] = "Failed";
    /** Updating */
    KnownOriginProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownOriginProvisioningState["Deleting"] = "Deleting";
    /** Creating */
    KnownOriginProvisioningState["Creating"] = "Creating";
})(exports.KnownOriginProvisioningState || (exports.KnownOriginProvisioningState = {}));
/** Known values of {@link OriginGroupResourceState} that the service accepts. */
exports.KnownOriginGroupResourceState = void 0;
(function (KnownOriginGroupResourceState) {
    /** Creating */
    KnownOriginGroupResourceState["Creating"] = "Creating";
    /** Active */
    KnownOriginGroupResourceState["Active"] = "Active";
    /** Deleting */
    KnownOriginGroupResourceState["Deleting"] = "Deleting";
})(exports.KnownOriginGroupResourceState || (exports.KnownOriginGroupResourceState = {}));
/** Known values of {@link OriginGroupProvisioningState} that the service accepts. */
exports.KnownOriginGroupProvisioningState = void 0;
(function (KnownOriginGroupProvisioningState) {
    /** Succeeded */
    KnownOriginGroupProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownOriginGroupProvisioningState["Failed"] = "Failed";
    /** Updating */
    KnownOriginGroupProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownOriginGroupProvisioningState["Deleting"] = "Deleting";
    /** Creating */
    KnownOriginGroupProvisioningState["Creating"] = "Creating";
})(exports.KnownOriginGroupProvisioningState || (exports.KnownOriginGroupProvisioningState = {}));
/** Known values of {@link CustomDomainResourceState} that the service accepts. */
exports.KnownCustomDomainResourceState = void 0;
(function (KnownCustomDomainResourceState) {
    /** Creating */
    KnownCustomDomainResourceState["Creating"] = "Creating";
    /** Active */
    KnownCustomDomainResourceState["Active"] = "Active";
    /** Deleting */
    KnownCustomDomainResourceState["Deleting"] = "Deleting";
})(exports.KnownCustomDomainResourceState || (exports.KnownCustomDomainResourceState = {}));
/** Known values of {@link CustomHttpsProvisioningState} that the service accepts. */
exports.KnownCustomHttpsProvisioningState = void 0;
(function (KnownCustomHttpsProvisioningState) {
    /** Enabling */
    KnownCustomHttpsProvisioningState["Enabling"] = "Enabling";
    /** Enabled */
    KnownCustomHttpsProvisioningState["Enabled"] = "Enabled";
    /** Disabling */
    KnownCustomHttpsProvisioningState["Disabling"] = "Disabling";
    /** Disabled */
    KnownCustomHttpsProvisioningState["Disabled"] = "Disabled";
    /** Failed */
    KnownCustomHttpsProvisioningState["Failed"] = "Failed";
})(exports.KnownCustomHttpsProvisioningState || (exports.KnownCustomHttpsProvisioningState = {}));
/** Known values of {@link CustomHttpsProvisioningSubstate} that the service accepts. */
exports.KnownCustomHttpsProvisioningSubstate = void 0;
(function (KnownCustomHttpsProvisioningSubstate) {
    /** SubmittingDomainControlValidationRequest */
    KnownCustomHttpsProvisioningSubstate["SubmittingDomainControlValidationRequest"] = "SubmittingDomainControlValidationRequest";
    /** PendingDomainControlValidationREquestApproval */
    KnownCustomHttpsProvisioningSubstate["PendingDomainControlValidationREquestApproval"] = "PendingDomainControlValidationREquestApproval";
    /** DomainControlValidationRequestApproved */
    KnownCustomHttpsProvisioningSubstate["DomainControlValidationRequestApproved"] = "DomainControlValidationRequestApproved";
    /** DomainControlValidationRequestRejected */
    KnownCustomHttpsProvisioningSubstate["DomainControlValidationRequestRejected"] = "DomainControlValidationRequestRejected";
    /** DomainControlValidationRequestTimedOut */
    KnownCustomHttpsProvisioningSubstate["DomainControlValidationRequestTimedOut"] = "DomainControlValidationRequestTimedOut";
    /** IssuingCertificate */
    KnownCustomHttpsProvisioningSubstate["IssuingCertificate"] = "IssuingCertificate";
    /** DeployingCertificate */
    KnownCustomHttpsProvisioningSubstate["DeployingCertificate"] = "DeployingCertificate";
    /** CertificateDeployed */
    KnownCustomHttpsProvisioningSubstate["CertificateDeployed"] = "CertificateDeployed";
    /** DeletingCertificate */
    KnownCustomHttpsProvisioningSubstate["DeletingCertificate"] = "DeletingCertificate";
    /** CertificateDeleted */
    KnownCustomHttpsProvisioningSubstate["CertificateDeleted"] = "CertificateDeleted";
})(exports.KnownCustomHttpsProvisioningSubstate || (exports.KnownCustomHttpsProvisioningSubstate = {}));
/** Known values of {@link CertificateSource} that the service accepts. */
exports.KnownCertificateSource = void 0;
(function (KnownCertificateSource) {
    /** AzureKeyVault */
    KnownCertificateSource["AzureKeyVault"] = "AzureKeyVault";
    /** Cdn */
    KnownCertificateSource["Cdn"] = "Cdn";
})(exports.KnownCertificateSource || (exports.KnownCertificateSource = {}));
/** Known values of {@link ProtocolType} that the service accepts. */
exports.KnownProtocolType = void 0;
(function (KnownProtocolType) {
    /** ServerNameIndication */
    KnownProtocolType["ServerNameIndication"] = "ServerNameIndication";
    /** IPBased */
    KnownProtocolType["IPBased"] = "IPBased";
})(exports.KnownProtocolType || (exports.KnownProtocolType = {}));
/** Known values of {@link PolicyEnabledState} that the service accepts. */
exports.KnownPolicyEnabledState = void 0;
(function (KnownPolicyEnabledState) {
    /** Disabled */
    KnownPolicyEnabledState["Disabled"] = "Disabled";
    /** Enabled */
    KnownPolicyEnabledState["Enabled"] = "Enabled";
})(exports.KnownPolicyEnabledState || (exports.KnownPolicyEnabledState = {}));
/** Known values of {@link PolicyMode} that the service accepts. */
exports.KnownPolicyMode = void 0;
(function (KnownPolicyMode) {
    /** Prevention */
    KnownPolicyMode["Prevention"] = "Prevention";
    /** Detection */
    KnownPolicyMode["Detection"] = "Detection";
})(exports.KnownPolicyMode || (exports.KnownPolicyMode = {}));
/** Known values of {@link PolicySettingsDefaultCustomBlockResponseStatusCode} that the service accepts. */
exports.KnownPolicySettingsDefaultCustomBlockResponseStatusCode = void 0;
(function (KnownPolicySettingsDefaultCustomBlockResponseStatusCode) {
    /** TwoHundred */
    KnownPolicySettingsDefaultCustomBlockResponseStatusCode[KnownPolicySettingsDefaultCustomBlockResponseStatusCode["TwoHundred"] = 200] = "TwoHundred";
    /** FourHundredThree */
    KnownPolicySettingsDefaultCustomBlockResponseStatusCode[KnownPolicySettingsDefaultCustomBlockResponseStatusCode["FourHundredThree"] = 403] = "FourHundredThree";
    /** FourHundredFive */
    KnownPolicySettingsDefaultCustomBlockResponseStatusCode[KnownPolicySettingsDefaultCustomBlockResponseStatusCode["FourHundredFive"] = 405] = "FourHundredFive";
    /** FourHundredSix */
    KnownPolicySettingsDefaultCustomBlockResponseStatusCode[KnownPolicySettingsDefaultCustomBlockResponseStatusCode["FourHundredSix"] = 406] = "FourHundredSix";
    /** FourHundredTwentyNine */
    KnownPolicySettingsDefaultCustomBlockResponseStatusCode[KnownPolicySettingsDefaultCustomBlockResponseStatusCode["FourHundredTwentyNine"] = 429] = "FourHundredTwentyNine";
})(exports.KnownPolicySettingsDefaultCustomBlockResponseStatusCode || (exports.KnownPolicySettingsDefaultCustomBlockResponseStatusCode = {}));
/** Known values of {@link CustomRuleEnabledState} that the service accepts. */
exports.KnownCustomRuleEnabledState = void 0;
(function (KnownCustomRuleEnabledState) {
    /** Disabled */
    KnownCustomRuleEnabledState["Disabled"] = "Disabled";
    /** Enabled */
    KnownCustomRuleEnabledState["Enabled"] = "Enabled";
})(exports.KnownCustomRuleEnabledState || (exports.KnownCustomRuleEnabledState = {}));
/** Known values of {@link WafMatchVariable} that the service accepts. */
exports.KnownWafMatchVariable = void 0;
(function (KnownWafMatchVariable) {
    /** RemoteAddr */
    KnownWafMatchVariable["RemoteAddr"] = "RemoteAddr";
    /** SocketAddr */
    KnownWafMatchVariable["SocketAddr"] = "SocketAddr";
    /** RequestMethod */
    KnownWafMatchVariable["RequestMethod"] = "RequestMethod";
    /** RequestHeader */
    KnownWafMatchVariable["RequestHeader"] = "RequestHeader";
    /** RequestUri */
    KnownWafMatchVariable["RequestUri"] = "RequestUri";
    /** QueryString */
    KnownWafMatchVariable["QueryString"] = "QueryString";
    /** RequestBody */
    KnownWafMatchVariable["RequestBody"] = "RequestBody";
    /** Cookies */
    KnownWafMatchVariable["Cookies"] = "Cookies";
    /** PostArgs */
    KnownWafMatchVariable["PostArgs"] = "PostArgs";
})(exports.KnownWafMatchVariable || (exports.KnownWafMatchVariable = {}));
/** Known values of {@link Operator} that the service accepts. */
exports.KnownOperator = void 0;
(function (KnownOperator) {
    /** Any */
    KnownOperator["Any"] = "Any";
    /** IPMatch */
    KnownOperator["IPMatch"] = "IPMatch";
    /** GeoMatch */
    KnownOperator["GeoMatch"] = "GeoMatch";
    /** Equal */
    KnownOperator["Equal"] = "Equal";
    /** Contains */
    KnownOperator["Contains"] = "Contains";
    /** LessThan */
    KnownOperator["LessThan"] = "LessThan";
    /** GreaterThan */
    KnownOperator["GreaterThan"] = "GreaterThan";
    /** LessThanOrEqual */
    KnownOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThanOrEqual */
    KnownOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** BeginsWith */
    KnownOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownOperator["EndsWith"] = "EndsWith";
    /** RegEx */
    KnownOperator["RegEx"] = "RegEx";
})(exports.KnownOperator || (exports.KnownOperator = {}));
/** Known values of {@link TransformType} that the service accepts. */
exports.KnownTransformType = void 0;
(function (KnownTransformType) {
    /** Lowercase */
    KnownTransformType["Lowercase"] = "Lowercase";
    /** Uppercase */
    KnownTransformType["Uppercase"] = "Uppercase";
    /** Trim */
    KnownTransformType["Trim"] = "Trim";
    /** UrlDecode */
    KnownTransformType["UrlDecode"] = "UrlDecode";
    /** UrlEncode */
    KnownTransformType["UrlEncode"] = "UrlEncode";
    /** RemoveNulls */
    KnownTransformType["RemoveNulls"] = "RemoveNulls";
})(exports.KnownTransformType || (exports.KnownTransformType = {}));
/** Known values of {@link ActionType} that the service accepts. */
exports.KnownActionType = void 0;
(function (KnownActionType) {
    /** Allow */
    KnownActionType["Allow"] = "Allow";
    /** Block */
    KnownActionType["Block"] = "Block";
    /** Log */
    KnownActionType["Log"] = "Log";
    /** Redirect */
    KnownActionType["Redirect"] = "Redirect";
})(exports.KnownActionType || (exports.KnownActionType = {}));
/** Known values of {@link ManagedRuleEnabledState} that the service accepts. */
exports.KnownManagedRuleEnabledState = void 0;
(function (KnownManagedRuleEnabledState) {
    /** Disabled */
    KnownManagedRuleEnabledState["Disabled"] = "Disabled";
    /** Enabled */
    KnownManagedRuleEnabledState["Enabled"] = "Enabled";
})(exports.KnownManagedRuleEnabledState || (exports.KnownManagedRuleEnabledState = {}));
/** Known values of {@link ProvisioningState} that the service accepts. */
exports.KnownProvisioningState = void 0;
(function (KnownProvisioningState) {
    /** Creating */
    KnownProvisioningState["Creating"] = "Creating";
    /** Succeeded */
    KnownProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownProvisioningState["Failed"] = "Failed";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
/** Known values of {@link PolicyResourceState} that the service accepts. */
exports.KnownPolicyResourceState = void 0;
(function (KnownPolicyResourceState) {
    /** Creating */
    KnownPolicyResourceState["Creating"] = "Creating";
    /** Enabling */
    KnownPolicyResourceState["Enabling"] = "Enabling";
    /** Enabled */
    KnownPolicyResourceState["Enabled"] = "Enabled";
    /** Disabling */
    KnownPolicyResourceState["Disabling"] = "Disabling";
    /** Disabled */
    KnownPolicyResourceState["Disabled"] = "Disabled";
    /** Deleting */
    KnownPolicyResourceState["Deleting"] = "Deleting";
})(exports.KnownPolicyResourceState || (exports.KnownPolicyResourceState = {}));
/** Known values of {@link RemoteAddressOperator} that the service accepts. */
exports.KnownRemoteAddressOperator = void 0;
(function (KnownRemoteAddressOperator) {
    /** Any */
    KnownRemoteAddressOperator["Any"] = "Any";
    /** IPMatch */
    KnownRemoteAddressOperator["IPMatch"] = "IPMatch";
    /** GeoMatch */
    KnownRemoteAddressOperator["GeoMatch"] = "GeoMatch";
})(exports.KnownRemoteAddressOperator || (exports.KnownRemoteAddressOperator = {}));
/** Known values of {@link Transform} that the service accepts. */
exports.KnownTransform = void 0;
(function (KnownTransform) {
    /** Lowercase */
    KnownTransform["Lowercase"] = "Lowercase";
    /** Uppercase */
    KnownTransform["Uppercase"] = "Uppercase";
    /** Trim */
    KnownTransform["Trim"] = "Trim";
    /** UrlDecode */
    KnownTransform["UrlDecode"] = "UrlDecode";
    /** UrlEncode */
    KnownTransform["UrlEncode"] = "UrlEncode";
    /** RemoveNulls */
    KnownTransform["RemoveNulls"] = "RemoveNulls";
})(exports.KnownTransform || (exports.KnownTransform = {}));
/** Known values of {@link RequestMethodOperator} that the service accepts. */
exports.KnownRequestMethodOperator = void 0;
(function (KnownRequestMethodOperator) {
    /** Equal */
    KnownRequestMethodOperator["Equal"] = "Equal";
})(exports.KnownRequestMethodOperator || (exports.KnownRequestMethodOperator = {}));
/** Known values of {@link RequestMethodMatchConditionParametersMatchValuesItem} that the service accepts. */
exports.KnownRequestMethodMatchConditionParametersMatchValuesItem = void 0;
(function (KnownRequestMethodMatchConditionParametersMatchValuesItem) {
    /** GET */
    KnownRequestMethodMatchConditionParametersMatchValuesItem["GET"] = "GET";
    /** Head */
    KnownRequestMethodMatchConditionParametersMatchValuesItem["Head"] = "HEAD";
    /** Post */
    KnownRequestMethodMatchConditionParametersMatchValuesItem["Post"] = "POST";
    /** PUT */
    KnownRequestMethodMatchConditionParametersMatchValuesItem["PUT"] = "PUT";
    /** Delete */
    KnownRequestMethodMatchConditionParametersMatchValuesItem["Delete"] = "DELETE";
    /** Options */
    KnownRequestMethodMatchConditionParametersMatchValuesItem["Options"] = "OPTIONS";
    /** Trace */
    KnownRequestMethodMatchConditionParametersMatchValuesItem["Trace"] = "TRACE";
})(exports.KnownRequestMethodMatchConditionParametersMatchValuesItem || (exports.KnownRequestMethodMatchConditionParametersMatchValuesItem = {}));
/** Known values of {@link QueryStringOperator} that the service accepts. */
exports.KnownQueryStringOperator = void 0;
(function (KnownQueryStringOperator) {
    /** Any */
    KnownQueryStringOperator["Any"] = "Any";
    /** Equal */
    KnownQueryStringOperator["Equal"] = "Equal";
    /** Contains */
    KnownQueryStringOperator["Contains"] = "Contains";
    /** BeginsWith */
    KnownQueryStringOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownQueryStringOperator["EndsWith"] = "EndsWith";
    /** LessThan */
    KnownQueryStringOperator["LessThan"] = "LessThan";
    /** LessThanOrEqual */
    KnownQueryStringOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThan */
    KnownQueryStringOperator["GreaterThan"] = "GreaterThan";
    /** GreaterThanOrEqual */
    KnownQueryStringOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** RegEx */
    KnownQueryStringOperator["RegEx"] = "RegEx";
})(exports.KnownQueryStringOperator || (exports.KnownQueryStringOperator = {}));
/** Known values of {@link PostArgsOperator} that the service accepts. */
exports.KnownPostArgsOperator = void 0;
(function (KnownPostArgsOperator) {
    /** Any */
    KnownPostArgsOperator["Any"] = "Any";
    /** Equal */
    KnownPostArgsOperator["Equal"] = "Equal";
    /** Contains */
    KnownPostArgsOperator["Contains"] = "Contains";
    /** BeginsWith */
    KnownPostArgsOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownPostArgsOperator["EndsWith"] = "EndsWith";
    /** LessThan */
    KnownPostArgsOperator["LessThan"] = "LessThan";
    /** LessThanOrEqual */
    KnownPostArgsOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThan */
    KnownPostArgsOperator["GreaterThan"] = "GreaterThan";
    /** GreaterThanOrEqual */
    KnownPostArgsOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** RegEx */
    KnownPostArgsOperator["RegEx"] = "RegEx";
})(exports.KnownPostArgsOperator || (exports.KnownPostArgsOperator = {}));
/** Known values of {@link RequestUriOperator} that the service accepts. */
exports.KnownRequestUriOperator = void 0;
(function (KnownRequestUriOperator) {
    /** Any */
    KnownRequestUriOperator["Any"] = "Any";
    /** Equal */
    KnownRequestUriOperator["Equal"] = "Equal";
    /** Contains */
    KnownRequestUriOperator["Contains"] = "Contains";
    /** BeginsWith */
    KnownRequestUriOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownRequestUriOperator["EndsWith"] = "EndsWith";
    /** LessThan */
    KnownRequestUriOperator["LessThan"] = "LessThan";
    /** LessThanOrEqual */
    KnownRequestUriOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThan */
    KnownRequestUriOperator["GreaterThan"] = "GreaterThan";
    /** GreaterThanOrEqual */
    KnownRequestUriOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** RegEx */
    KnownRequestUriOperator["RegEx"] = "RegEx";
})(exports.KnownRequestUriOperator || (exports.KnownRequestUriOperator = {}));
/** Known values of {@link RequestHeaderOperator} that the service accepts. */
exports.KnownRequestHeaderOperator = void 0;
(function (KnownRequestHeaderOperator) {
    /** Any */
    KnownRequestHeaderOperator["Any"] = "Any";
    /** Equal */
    KnownRequestHeaderOperator["Equal"] = "Equal";
    /** Contains */
    KnownRequestHeaderOperator["Contains"] = "Contains";
    /** BeginsWith */
    KnownRequestHeaderOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownRequestHeaderOperator["EndsWith"] = "EndsWith";
    /** LessThan */
    KnownRequestHeaderOperator["LessThan"] = "LessThan";
    /** LessThanOrEqual */
    KnownRequestHeaderOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThan */
    KnownRequestHeaderOperator["GreaterThan"] = "GreaterThan";
    /** GreaterThanOrEqual */
    KnownRequestHeaderOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** RegEx */
    KnownRequestHeaderOperator["RegEx"] = "RegEx";
})(exports.KnownRequestHeaderOperator || (exports.KnownRequestHeaderOperator = {}));
/** Known values of {@link RequestBodyOperator} that the service accepts. */
exports.KnownRequestBodyOperator = void 0;
(function (KnownRequestBodyOperator) {
    /** Any */
    KnownRequestBodyOperator["Any"] = "Any";
    /** Equal */
    KnownRequestBodyOperator["Equal"] = "Equal";
    /** Contains */
    KnownRequestBodyOperator["Contains"] = "Contains";
    /** BeginsWith */
    KnownRequestBodyOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownRequestBodyOperator["EndsWith"] = "EndsWith";
    /** LessThan */
    KnownRequestBodyOperator["LessThan"] = "LessThan";
    /** LessThanOrEqual */
    KnownRequestBodyOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThan */
    KnownRequestBodyOperator["GreaterThan"] = "GreaterThan";
    /** GreaterThanOrEqual */
    KnownRequestBodyOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** RegEx */
    KnownRequestBodyOperator["RegEx"] = "RegEx";
})(exports.KnownRequestBodyOperator || (exports.KnownRequestBodyOperator = {}));
/** Known values of {@link RequestSchemeMatchConditionParametersMatchValuesItem} that the service accepts. */
exports.KnownRequestSchemeMatchConditionParametersMatchValuesItem = void 0;
(function (KnownRequestSchemeMatchConditionParametersMatchValuesItem) {
    /** Http */
    KnownRequestSchemeMatchConditionParametersMatchValuesItem["Http"] = "HTTP";
    /** Https */
    KnownRequestSchemeMatchConditionParametersMatchValuesItem["Https"] = "HTTPS";
})(exports.KnownRequestSchemeMatchConditionParametersMatchValuesItem || (exports.KnownRequestSchemeMatchConditionParametersMatchValuesItem = {}));
/** Known values of {@link UrlPathOperator} that the service accepts. */
exports.KnownUrlPathOperator = void 0;
(function (KnownUrlPathOperator) {
    /** Any */
    KnownUrlPathOperator["Any"] = "Any";
    /** Equal */
    KnownUrlPathOperator["Equal"] = "Equal";
    /** Contains */
    KnownUrlPathOperator["Contains"] = "Contains";
    /** BeginsWith */
    KnownUrlPathOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownUrlPathOperator["EndsWith"] = "EndsWith";
    /** LessThan */
    KnownUrlPathOperator["LessThan"] = "LessThan";
    /** LessThanOrEqual */
    KnownUrlPathOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThan */
    KnownUrlPathOperator["GreaterThan"] = "GreaterThan";
    /** GreaterThanOrEqual */
    KnownUrlPathOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** Wildcard */
    KnownUrlPathOperator["Wildcard"] = "Wildcard";
    /** RegEx */
    KnownUrlPathOperator["RegEx"] = "RegEx";
})(exports.KnownUrlPathOperator || (exports.KnownUrlPathOperator = {}));
/** Known values of {@link UrlFileExtensionOperator} that the service accepts. */
exports.KnownUrlFileExtensionOperator = void 0;
(function (KnownUrlFileExtensionOperator) {
    /** Any */
    KnownUrlFileExtensionOperator["Any"] = "Any";
    /** Equal */
    KnownUrlFileExtensionOperator["Equal"] = "Equal";
    /** Contains */
    KnownUrlFileExtensionOperator["Contains"] = "Contains";
    /** BeginsWith */
    KnownUrlFileExtensionOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownUrlFileExtensionOperator["EndsWith"] = "EndsWith";
    /** LessThan */
    KnownUrlFileExtensionOperator["LessThan"] = "LessThan";
    /** LessThanOrEqual */
    KnownUrlFileExtensionOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThan */
    KnownUrlFileExtensionOperator["GreaterThan"] = "GreaterThan";
    /** GreaterThanOrEqual */
    KnownUrlFileExtensionOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** RegEx */
    KnownUrlFileExtensionOperator["RegEx"] = "RegEx";
})(exports.KnownUrlFileExtensionOperator || (exports.KnownUrlFileExtensionOperator = {}));
/** Known values of {@link UrlFileNameOperator} that the service accepts. */
exports.KnownUrlFileNameOperator = void 0;
(function (KnownUrlFileNameOperator) {
    /** Any */
    KnownUrlFileNameOperator["Any"] = "Any";
    /** Equal */
    KnownUrlFileNameOperator["Equal"] = "Equal";
    /** Contains */
    KnownUrlFileNameOperator["Contains"] = "Contains";
    /** BeginsWith */
    KnownUrlFileNameOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownUrlFileNameOperator["EndsWith"] = "EndsWith";
    /** LessThan */
    KnownUrlFileNameOperator["LessThan"] = "LessThan";
    /** LessThanOrEqual */
    KnownUrlFileNameOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThan */
    KnownUrlFileNameOperator["GreaterThan"] = "GreaterThan";
    /** GreaterThanOrEqual */
    KnownUrlFileNameOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** RegEx */
    KnownUrlFileNameOperator["RegEx"] = "RegEx";
})(exports.KnownUrlFileNameOperator || (exports.KnownUrlFileNameOperator = {}));
/** Known values of {@link HttpVersionOperator} that the service accepts. */
exports.KnownHttpVersionOperator = void 0;
(function (KnownHttpVersionOperator) {
    /** Equal */
    KnownHttpVersionOperator["Equal"] = "Equal";
})(exports.KnownHttpVersionOperator || (exports.KnownHttpVersionOperator = {}));
/** Known values of {@link CookiesOperator} that the service accepts. */
exports.KnownCookiesOperator = void 0;
(function (KnownCookiesOperator) {
    /** Any */
    KnownCookiesOperator["Any"] = "Any";
    /** Equal */
    KnownCookiesOperator["Equal"] = "Equal";
    /** Contains */
    KnownCookiesOperator["Contains"] = "Contains";
    /** BeginsWith */
    KnownCookiesOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownCookiesOperator["EndsWith"] = "EndsWith";
    /** LessThan */
    KnownCookiesOperator["LessThan"] = "LessThan";
    /** LessThanOrEqual */
    KnownCookiesOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThan */
    KnownCookiesOperator["GreaterThan"] = "GreaterThan";
    /** GreaterThanOrEqual */
    KnownCookiesOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** RegEx */
    KnownCookiesOperator["RegEx"] = "RegEx";
})(exports.KnownCookiesOperator || (exports.KnownCookiesOperator = {}));
/** Known values of {@link IsDeviceOperator} that the service accepts. */
exports.KnownIsDeviceOperator = void 0;
(function (KnownIsDeviceOperator) {
    /** Equal */
    KnownIsDeviceOperator["Equal"] = "Equal";
})(exports.KnownIsDeviceOperator || (exports.KnownIsDeviceOperator = {}));
/** Known values of {@link IsDeviceMatchConditionParametersMatchValuesItem} that the service accepts. */
exports.KnownIsDeviceMatchConditionParametersMatchValuesItem = void 0;
(function (KnownIsDeviceMatchConditionParametersMatchValuesItem) {
    /** Mobile */
    KnownIsDeviceMatchConditionParametersMatchValuesItem["Mobile"] = "Mobile";
    /** Desktop */
    KnownIsDeviceMatchConditionParametersMatchValuesItem["Desktop"] = "Desktop";
})(exports.KnownIsDeviceMatchConditionParametersMatchValuesItem || (exports.KnownIsDeviceMatchConditionParametersMatchValuesItem = {}));
/** Known values of {@link SocketAddrOperator} that the service accepts. */
exports.KnownSocketAddrOperator = void 0;
(function (KnownSocketAddrOperator) {
    /** Any */
    KnownSocketAddrOperator["Any"] = "Any";
    /** IPMatch */
    KnownSocketAddrOperator["IPMatch"] = "IPMatch";
})(exports.KnownSocketAddrOperator || (exports.KnownSocketAddrOperator = {}));
/** Known values of {@link ClientPortOperator} that the service accepts. */
exports.KnownClientPortOperator = void 0;
(function (KnownClientPortOperator) {
    /** Any */
    KnownClientPortOperator["Any"] = "Any";
    /** Equal */
    KnownClientPortOperator["Equal"] = "Equal";
    /** Contains */
    KnownClientPortOperator["Contains"] = "Contains";
    /** BeginsWith */
    KnownClientPortOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownClientPortOperator["EndsWith"] = "EndsWith";
    /** LessThan */
    KnownClientPortOperator["LessThan"] = "LessThan";
    /** LessThanOrEqual */
    KnownClientPortOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThan */
    KnownClientPortOperator["GreaterThan"] = "GreaterThan";
    /** GreaterThanOrEqual */
    KnownClientPortOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** RegEx */
    KnownClientPortOperator["RegEx"] = "RegEx";
})(exports.KnownClientPortOperator || (exports.KnownClientPortOperator = {}));
/** Known values of {@link ServerPortOperator} that the service accepts. */
exports.KnownServerPortOperator = void 0;
(function (KnownServerPortOperator) {
    /** Any */
    KnownServerPortOperator["Any"] = "Any";
    /** Equal */
    KnownServerPortOperator["Equal"] = "Equal";
    /** Contains */
    KnownServerPortOperator["Contains"] = "Contains";
    /** BeginsWith */
    KnownServerPortOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownServerPortOperator["EndsWith"] = "EndsWith";
    /** LessThan */
    KnownServerPortOperator["LessThan"] = "LessThan";
    /** LessThanOrEqual */
    KnownServerPortOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThan */
    KnownServerPortOperator["GreaterThan"] = "GreaterThan";
    /** GreaterThanOrEqual */
    KnownServerPortOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** RegEx */
    KnownServerPortOperator["RegEx"] = "RegEx";
})(exports.KnownServerPortOperator || (exports.KnownServerPortOperator = {}));
/** Known values of {@link HostNameOperator} that the service accepts. */
exports.KnownHostNameOperator = void 0;
(function (KnownHostNameOperator) {
    /** Any */
    KnownHostNameOperator["Any"] = "Any";
    /** Equal */
    KnownHostNameOperator["Equal"] = "Equal";
    /** Contains */
    KnownHostNameOperator["Contains"] = "Contains";
    /** BeginsWith */
    KnownHostNameOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownHostNameOperator["EndsWith"] = "EndsWith";
    /** LessThan */
    KnownHostNameOperator["LessThan"] = "LessThan";
    /** LessThanOrEqual */
    KnownHostNameOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThan */
    KnownHostNameOperator["GreaterThan"] = "GreaterThan";
    /** GreaterThanOrEqual */
    KnownHostNameOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** RegEx */
    KnownHostNameOperator["RegEx"] = "RegEx";
})(exports.KnownHostNameOperator || (exports.KnownHostNameOperator = {}));
/** Known values of {@link SslProtocolOperator} that the service accepts. */
exports.KnownSslProtocolOperator = void 0;
(function (KnownSslProtocolOperator) {
    /** Equal */
    KnownSslProtocolOperator["Equal"] = "Equal";
})(exports.KnownSslProtocolOperator || (exports.KnownSslProtocolOperator = {}));
/** Known values of {@link SslProtocol} that the service accepts. */
exports.KnownSslProtocol = void 0;
(function (KnownSslProtocol) {
    /** TLSv1 */
    KnownSslProtocol["TLSv1"] = "TLSv1";
    /** TLSv11 */
    KnownSslProtocol["TLSv11"] = "TLSv1.1";
    /** TLSv12 */
    KnownSslProtocol["TLSv12"] = "TLSv1.2";
})(exports.KnownSslProtocol || (exports.KnownSslProtocol = {}));
/** Known values of {@link RedirectType} that the service accepts. */
exports.KnownRedirectType = void 0;
(function (KnownRedirectType) {
    /** Moved */
    KnownRedirectType["Moved"] = "Moved";
    /** Found */
    KnownRedirectType["Found"] = "Found";
    /** TemporaryRedirect */
    KnownRedirectType["TemporaryRedirect"] = "TemporaryRedirect";
    /** PermanentRedirect */
    KnownRedirectType["PermanentRedirect"] = "PermanentRedirect";
})(exports.KnownRedirectType || (exports.KnownRedirectType = {}));
/** Known values of {@link DestinationProtocol} that the service accepts. */
exports.KnownDestinationProtocol = void 0;
(function (KnownDestinationProtocol) {
    /** MatchRequest */
    KnownDestinationProtocol["MatchRequest"] = "MatchRequest";
    /** Http */
    KnownDestinationProtocol["Http"] = "Http";
    /** Https */
    KnownDestinationProtocol["Https"] = "Https";
})(exports.KnownDestinationProtocol || (exports.KnownDestinationProtocol = {}));
/** Known values of {@link Algorithm} that the service accepts. */
exports.KnownAlgorithm = void 0;
(function (KnownAlgorithm) {
    /** SHA256 */
    KnownAlgorithm["SHA256"] = "SHA256";
})(exports.KnownAlgorithm || (exports.KnownAlgorithm = {}));
/** Known values of {@link ParamIndicator} that the service accepts. */
exports.KnownParamIndicator = void 0;
(function (KnownParamIndicator) {
    /** Expires */
    KnownParamIndicator["Expires"] = "Expires";
    /** KeyId */
    KnownParamIndicator["KeyId"] = "KeyId";
    /** Signature */
    KnownParamIndicator["Signature"] = "Signature";
})(exports.KnownParamIndicator || (exports.KnownParamIndicator = {}));
/** Known values of {@link HeaderAction} that the service accepts. */
exports.KnownHeaderAction = void 0;
(function (KnownHeaderAction) {
    /** Append */
    KnownHeaderAction["Append"] = "Append";
    /** Overwrite */
    KnownHeaderAction["Overwrite"] = "Overwrite";
    /** Delete */
    KnownHeaderAction["Delete"] = "Delete";
})(exports.KnownHeaderAction || (exports.KnownHeaderAction = {}));
/** Known values of {@link CacheBehavior} that the service accepts. */
exports.KnownCacheBehavior = void 0;
(function (KnownCacheBehavior) {
    /** BypassCache */
    KnownCacheBehavior["BypassCache"] = "BypassCache";
    /** Override */
    KnownCacheBehavior["Override"] = "Override";
    /** SetIfMissing */
    KnownCacheBehavior["SetIfMissing"] = "SetIfMissing";
})(exports.KnownCacheBehavior || (exports.KnownCacheBehavior = {}));
/** Known values of {@link CacheType} that the service accepts. */
exports.KnownCacheType = void 0;
(function (KnownCacheType) {
    /** All */
    KnownCacheType["All"] = "All";
})(exports.KnownCacheType || (exports.KnownCacheType = {}));
/** Known values of {@link QueryStringBehavior} that the service accepts. */
exports.KnownQueryStringBehavior = void 0;
(function (KnownQueryStringBehavior) {
    /** Include */
    KnownQueryStringBehavior["Include"] = "Include";
    /** IncludeAll */
    KnownQueryStringBehavior["IncludeAll"] = "IncludeAll";
    /** Exclude */
    KnownQueryStringBehavior["Exclude"] = "Exclude";
    /** ExcludeAll */
    KnownQueryStringBehavior["ExcludeAll"] = "ExcludeAll";
})(exports.KnownQueryStringBehavior || (exports.KnownQueryStringBehavior = {}));
/** Known values of {@link RuleQueryStringCachingBehavior} that the service accepts. */
exports.KnownRuleQueryStringCachingBehavior = void 0;
(function (KnownRuleQueryStringCachingBehavior) {
    /** IgnoreQueryString */
    KnownRuleQueryStringCachingBehavior["IgnoreQueryString"] = "IgnoreQueryString";
    /** UseQueryString */
    KnownRuleQueryStringCachingBehavior["UseQueryString"] = "UseQueryString";
    /** IgnoreSpecifiedQueryStrings */
    KnownRuleQueryStringCachingBehavior["IgnoreSpecifiedQueryStrings"] = "IgnoreSpecifiedQueryStrings";
    /** IncludeSpecifiedQueryStrings */
    KnownRuleQueryStringCachingBehavior["IncludeSpecifiedQueryStrings"] = "IncludeSpecifiedQueryStrings";
})(exports.KnownRuleQueryStringCachingBehavior || (exports.KnownRuleQueryStringCachingBehavior = {}));
/** Known values of {@link RuleIsCompressionEnabled} that the service accepts. */
exports.KnownRuleIsCompressionEnabled = void 0;
(function (KnownRuleIsCompressionEnabled) {
    /** Enabled */
    KnownRuleIsCompressionEnabled["Enabled"] = "Enabled";
    /** Disabled */
    KnownRuleIsCompressionEnabled["Disabled"] = "Disabled";
})(exports.KnownRuleIsCompressionEnabled || (exports.KnownRuleIsCompressionEnabled = {}));
/** Known values of {@link RuleCacheBehavior} that the service accepts. */
exports.KnownRuleCacheBehavior = void 0;
(function (KnownRuleCacheBehavior) {
    /** HonorOrigin */
    KnownRuleCacheBehavior["HonorOrigin"] = "HonorOrigin";
    /** OverrideAlways */
    KnownRuleCacheBehavior["OverrideAlways"] = "OverrideAlways";
    /** OverrideIfOriginMissing */
    KnownRuleCacheBehavior["OverrideIfOriginMissing"] = "OverrideIfOriginMissing";
})(exports.KnownRuleCacheBehavior || (exports.KnownRuleCacheBehavior = {}));
/** Known values of {@link CertificateType} that the service accepts. */
exports.KnownCertificateType = void 0;
(function (KnownCertificateType) {
    /** Shared */
    KnownCertificateType["Shared"] = "Shared";
    /** Dedicated */
    KnownCertificateType["Dedicated"] = "Dedicated";
})(exports.KnownCertificateType || (exports.KnownCertificateType = {}));
/** Known values of {@link UpdateRule} that the service accepts. */
exports.KnownUpdateRule = void 0;
(function (KnownUpdateRule) {
    /** NoAction */
    KnownUpdateRule["NoAction"] = "NoAction";
})(exports.KnownUpdateRule || (exports.KnownUpdateRule = {}));
/** Known values of {@link DeleteRule} that the service accepts. */
exports.KnownDeleteRule = void 0;
(function (KnownDeleteRule) {
    /** NoAction */
    KnownDeleteRule["NoAction"] = "NoAction";
})(exports.KnownDeleteRule || (exports.KnownDeleteRule = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const CheckEndpointNameAvailabilityInput = {
    type: {
        name: "Composite",
        className: "CheckEndpointNameAvailabilityInput",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            autoGeneratedDomainNameLabelScope: {
                serializedName: "autoGeneratedDomainNameLabelScope",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckEndpointNameAvailabilityOutput = {
    type: {
        name: "Composite",
        className: "CheckEndpointNameAvailabilityOutput",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            availableHostname: {
                serializedName: "availableHostname",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AfdErrorResponse = {
    type: {
        name: "Composite",
        className: "AfdErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const UsagesListResult = {
    type: {
        name: "Composite",
        className: "UsagesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Usage = {
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                required: true,
                type: {
                    name: "String"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                required: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                required: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "UsageName"
                }
            }
        }
    }
};
const UsageName = {
    type: {
        name: "Composite",
        className: "UsageName",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckHostNameAvailabilityInput = {
    type: {
        name: "Composite",
        className: "CheckHostNameAvailabilityInput",
        modelProperties: {
            hostName: {
                serializedName: "hostName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityOutput = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityOutput",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AFDDomainListResult = {
    type: {
        name: "Composite",
        className: "AFDDomainListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AFDDomain"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DomainValidationProperties = {
    type: {
        name: "Composite",
        className: "DomainValidationProperties",
        modelProperties: {
            validationToken: {
                serializedName: "validationToken",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            expirationDate: {
                serializedName: "expirationDate",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AFDDomainUpdatePropertiesParameters = {
    type: {
        name: "Composite",
        className: "AFDDomainUpdatePropertiesParameters",
        modelProperties: {
            profileName: {
                serializedName: "profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tlsSettings: {
                serializedName: "tlsSettings",
                type: {
                    name: "Composite",
                    className: "AFDDomainHttpsParameters"
                }
            },
            azureDnsZone: {
                serializedName: "azureDnsZone",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            },
            preValidatedCustomDomainResourceId: {
                serializedName: "preValidatedCustomDomainResourceId",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }
        }
    }
};
const AFDDomainHttpsParameters = {
    type: {
        name: "Composite",
        className: "AFDDomainHttpsParameters",
        modelProperties: {
            certificateType: {
                serializedName: "certificateType",
                required: true,
                type: {
                    name: "String"
                }
            },
            minimumTlsVersion: {
                serializedName: "minimumTlsVersion",
                type: {
                    name: "Enum",
                    allowedValues: ["TLS10", "TLS12"]
                }
            },
            secret: {
                serializedName: "secret",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }
        }
    }
};
const ResourceReference = {
    type: {
        name: "Composite",
        className: "ResourceReference",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AFDStateProperties = {
    type: {
        name: "Composite",
        className: "AFDStateProperties",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            deploymentStatus: {
                serializedName: "deploymentStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const AFDDomainUpdateParameters = {
    type: {
        name: "Composite",
        className: "AFDDomainUpdateParameters",
        modelProperties: {
            profileName: {
                serializedName: "properties.profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tlsSettings: {
                serializedName: "properties.tlsSettings",
                type: {
                    name: "Composite",
                    className: "AFDDomainHttpsParameters"
                }
            },
            azureDnsZone: {
                serializedName: "properties.azureDnsZone",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            },
            preValidatedCustomDomainResourceId: {
                serializedName: "properties.preValidatedCustomDomainResourceId",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }
        }
    }
};
const AFDEndpointListResult = {
    type: {
        name: "Composite",
        className: "AFDEndpointListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AFDEndpoint"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AFDEndpointPropertiesUpdateParameters = {
    type: {
        name: "Composite",
        className: "AFDEndpointPropertiesUpdateParameters",
        modelProperties: {
            profileName: {
                serializedName: "profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            enabledState: {
                serializedName: "enabledState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AFDEndpointUpdateParameters = {
    type: {
        name: "Composite",
        className: "AFDEndpointUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            profileName: {
                serializedName: "properties.profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AfdPurgeParameters = {
    type: {
        name: "Composite",
        className: "AfdPurgeParameters",
        modelProperties: {
            contentPaths: {
                serializedName: "contentPaths",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            domains: {
                serializedName: "domains",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ValidateCustomDomainInput = {
    type: {
        name: "Composite",
        className: "ValidateCustomDomainInput",
        modelProperties: {
            hostName: {
                serializedName: "hostName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ValidateCustomDomainOutput = {
    type: {
        name: "Composite",
        className: "ValidateCustomDomainOutput",
        modelProperties: {
            customDomainValidated: {
                serializedName: "customDomainValidated",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AFDOriginGroupListResult = {
    type: {
        name: "Composite",
        className: "AFDOriginGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AFDOriginGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AFDOriginGroupUpdatePropertiesParameters = {
    type: {
        name: "Composite",
        className: "AFDOriginGroupUpdatePropertiesParameters",
        modelProperties: {
            profileName: {
                serializedName: "profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            loadBalancingSettings: {
                serializedName: "loadBalancingSettings",
                type: {
                    name: "Composite",
                    className: "LoadBalancingSettingsParameters"
                }
            },
            healthProbeSettings: {
                serializedName: "healthProbeSettings",
                type: {
                    name: "Composite",
                    className: "HealthProbeParameters"
                }
            },
            trafficRestorationTimeToHealedOrNewEndpointsInMinutes: {
                constraints: {
                    InclusiveMaximum: 50,
                    InclusiveMinimum: 0
                },
                serializedName: "trafficRestorationTimeToHealedOrNewEndpointsInMinutes",
                type: {
                    name: "Number"
                }
            },
            sessionAffinityState: {
                serializedName: "sessionAffinityState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancingSettingsParameters = {
    type: {
        name: "Composite",
        className: "LoadBalancingSettingsParameters",
        modelProperties: {
            sampleSize: {
                serializedName: "sampleSize",
                type: {
                    name: "Number"
                }
            },
            successfulSamplesRequired: {
                serializedName: "successfulSamplesRequired",
                type: {
                    name: "Number"
                }
            },
            additionalLatencyInMilliseconds: {
                serializedName: "additionalLatencyInMilliseconds",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const HealthProbeParameters = {
    type: {
        name: "Composite",
        className: "HealthProbeParameters",
        modelProperties: {
            probePath: {
                serializedName: "probePath",
                type: {
                    name: "String"
                }
            },
            probeRequestType: {
                serializedName: "probeRequestType",
                type: {
                    name: "Enum",
                    allowedValues: ["NotSet", "GET", "HEAD"]
                }
            },
            probeProtocol: {
                serializedName: "probeProtocol",
                type: {
                    name: "Enum",
                    allowedValues: ["NotSet", "Http", "Https"]
                }
            },
            probeIntervalInSeconds: {
                constraints: {
                    InclusiveMaximum: 255,
                    InclusiveMinimum: 1
                },
                serializedName: "probeIntervalInSeconds",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AFDOriginGroupUpdateParameters = {
    type: {
        name: "Composite",
        className: "AFDOriginGroupUpdateParameters",
        modelProperties: {
            profileName: {
                serializedName: "properties.profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            loadBalancingSettings: {
                serializedName: "properties.loadBalancingSettings",
                type: {
                    name: "Composite",
                    className: "LoadBalancingSettingsParameters"
                }
            },
            healthProbeSettings: {
                serializedName: "properties.healthProbeSettings",
                type: {
                    name: "Composite",
                    className: "HealthProbeParameters"
                }
            },
            trafficRestorationTimeToHealedOrNewEndpointsInMinutes: {
                constraints: {
                    InclusiveMaximum: 50,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.trafficRestorationTimeToHealedOrNewEndpointsInMinutes",
                type: {
                    name: "Number"
                }
            },
            sessionAffinityState: {
                serializedName: "properties.sessionAffinityState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AFDOriginListResult = {
    type: {
        name: "Composite",
        className: "AFDOriginListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AFDOrigin"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AFDOriginUpdatePropertiesParameters = {
    type: {
        name: "Composite",
        className: "AFDOriginUpdatePropertiesParameters",
        modelProperties: {
            originGroupName: {
                serializedName: "originGroupName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            azureOrigin: {
                serializedName: "azureOrigin",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            },
            hostName: {
                serializedName: "hostName",
                type: {
                    name: "String"
                }
            },
            httpPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "httpPort",
                type: {
                    name: "Number"
                }
            },
            httpsPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "httpsPort",
                type: {
                    name: "Number"
                }
            },
            originHostHeader: {
                serializedName: "originHostHeader",
                type: {
                    name: "String"
                }
            },
            priority: {
                constraints: {
                    InclusiveMaximum: 5,
                    InclusiveMinimum: 1
                },
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            },
            weight: {
                constraints: {
                    InclusiveMaximum: 1000,
                    InclusiveMinimum: 1
                },
                serializedName: "weight",
                type: {
                    name: "Number"
                }
            },
            sharedPrivateLinkResource: {
                serializedName: "sharedPrivateLinkResource",
                type: {
                    name: "Composite",
                    className: "SharedPrivateLinkResourceProperties"
                }
            },
            enabledState: {
                serializedName: "enabledState",
                type: {
                    name: "String"
                }
            },
            enforceCertificateNameCheck: {
                defaultValue: true,
                serializedName: "enforceCertificateNameCheck",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SharedPrivateLinkResourceProperties = {
    type: {
        name: "Composite",
        className: "SharedPrivateLinkResourceProperties",
        modelProperties: {
            privateLink: {
                serializedName: "privateLink",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            },
            privateLinkLocation: {
                serializedName: "privateLinkLocation",
                type: {
                    name: "String"
                }
            },
            groupId: {
                serializedName: "groupId",
                type: {
                    name: "String"
                }
            },
            requestMessage: {
                serializedName: "requestMessage",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Pending",
                        "Approved",
                        "Rejected",
                        "Disconnected",
                        "Timeout"
                    ]
                }
            }
        }
    }
};
const AFDOriginUpdateParameters = {
    type: {
        name: "Composite",
        className: "AFDOriginUpdateParameters",
        modelProperties: {
            originGroupName: {
                serializedName: "properties.originGroupName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            azureOrigin: {
                serializedName: "properties.azureOrigin",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            },
            hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String"
                }
            },
            httpPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.httpPort",
                type: {
                    name: "Number"
                }
            },
            httpsPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.httpsPort",
                type: {
                    name: "Number"
                }
            },
            originHostHeader: {
                serializedName: "properties.originHostHeader",
                type: {
                    name: "String"
                }
            },
            priority: {
                constraints: {
                    InclusiveMaximum: 5,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            },
            weight: {
                constraints: {
                    InclusiveMaximum: 1000,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.weight",
                type: {
                    name: "Number"
                }
            },
            sharedPrivateLinkResource: {
                serializedName: "properties.sharedPrivateLinkResource",
                type: {
                    name: "Composite",
                    className: "SharedPrivateLinkResourceProperties"
                }
            },
            enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "String"
                }
            },
            enforceCertificateNameCheck: {
                defaultValue: true,
                serializedName: "properties.enforceCertificateNameCheck",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const RouteListResult = {
    type: {
        name: "Composite",
        className: "RouteListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Route"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RouteUpdatePropertiesParameters = {
    type: {
        name: "Composite",
        className: "RouteUpdatePropertiesParameters",
        modelProperties: {
            endpointName: {
                serializedName: "endpointName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            customDomains: {
                serializedName: "customDomains",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ActivatedResourceReference"
                        }
                    }
                }
            },
            originGroup: {
                serializedName: "originGroup",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            },
            originPath: {
                serializedName: "originPath",
                type: {
                    name: "String"
                }
            },
            ruleSets: {
                serializedName: "ruleSets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceReference"
                        }
                    }
                }
            },
            supportedProtocols: {
                serializedName: "supportedProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            patternsToMatch: {
                serializedName: "patternsToMatch",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            cacheConfiguration: {
                serializedName: "cacheConfiguration",
                type: {
                    name: "Composite",
                    className: "AfdRouteCacheConfiguration"
                }
            },
            forwardingProtocol: {
                serializedName: "forwardingProtocol",
                type: {
                    name: "String"
                }
            },
            linkToDefaultDomain: {
                serializedName: "linkToDefaultDomain",
                type: {
                    name: "String"
                }
            },
            httpsRedirect: {
                serializedName: "httpsRedirect",
                type: {
                    name: "String"
                }
            },
            enabledState: {
                serializedName: "enabledState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ActivatedResourceReference = {
    type: {
        name: "Composite",
        className: "ActivatedResourceReference",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            isActive: {
                serializedName: "isActive",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AfdRouteCacheConfiguration = {
    type: {
        name: "Composite",
        className: "AfdRouteCacheConfiguration",
        modelProperties: {
            queryStringCachingBehavior: {
                serializedName: "queryStringCachingBehavior",
                type: {
                    name: "String"
                }
            },
            queryParameters: {
                serializedName: "queryParameters",
                type: {
                    name: "String"
                }
            },
            compressionSettings: {
                serializedName: "compressionSettings",
                type: {
                    name: "Composite",
                    className: "CompressionSettings"
                }
            }
        }
    }
};
const CompressionSettings = {
    type: {
        name: "Composite",
        className: "CompressionSettings",
        modelProperties: {
            contentTypesToCompress: {
                serializedName: "contentTypesToCompress",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            isCompressionEnabled: {
                serializedName: "isCompressionEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const RouteUpdateParameters = {
    type: {
        name: "Composite",
        className: "RouteUpdateParameters",
        modelProperties: {
            endpointName: {
                serializedName: "properties.endpointName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            customDomains: {
                serializedName: "properties.customDomains",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ActivatedResourceReference"
                        }
                    }
                }
            },
            originGroup: {
                serializedName: "properties.originGroup",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            },
            originPath: {
                serializedName: "properties.originPath",
                type: {
                    name: "String"
                }
            },
            ruleSets: {
                serializedName: "properties.ruleSets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceReference"
                        }
                    }
                }
            },
            supportedProtocols: {
                serializedName: "properties.supportedProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            patternsToMatch: {
                serializedName: "properties.patternsToMatch",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            cacheConfiguration: {
                serializedName: "properties.cacheConfiguration",
                type: {
                    name: "Composite",
                    className: "AfdRouteCacheConfiguration"
                }
            },
            forwardingProtocol: {
                serializedName: "properties.forwardingProtocol",
                type: {
                    name: "String"
                }
            },
            linkToDefaultDomain: {
                serializedName: "properties.linkToDefaultDomain",
                type: {
                    name: "String"
                }
            },
            httpsRedirect: {
                serializedName: "properties.httpsRedirect",
                type: {
                    name: "String"
                }
            },
            enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RuleSetListResult = {
    type: {
        name: "Composite",
        className: "RuleSetListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RuleSet"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RuleListResult = {
    type: {
        name: "Composite",
        className: "RuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Rule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RuleUpdatePropertiesParameters = {
    type: {
        name: "Composite",
        className: "RuleUpdatePropertiesParameters",
        modelProperties: {
            ruleSetName: {
                serializedName: "ruleSetName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            order: {
                serializedName: "order",
                type: {
                    name: "Number"
                }
            },
            conditions: {
                serializedName: "conditions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryRuleCondition"
                        }
                    }
                }
            },
            actions: {
                serializedName: "actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryRuleActionAutoGenerated"
                        }
                    }
                }
            },
            matchProcessingBehavior: {
                serializedName: "matchProcessingBehavior",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeliveryRuleCondition = {
    type: {
        name: "Composite",
        className: "DeliveryRuleCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: {
            serializedName: "name",
            clientName: "name"
        },
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeliveryRuleActionAutoGenerated = {
    type: {
        name: "Composite",
        className: "DeliveryRuleActionAutoGenerated",
        uberParent: "DeliveryRuleActionAutoGenerated",
        polymorphicDiscriminator: {
            serializedName: "name",
            clientName: "name"
        },
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RuleUpdateParameters = {
    type: {
        name: "Composite",
        className: "RuleUpdateParameters",
        modelProperties: {
            ruleSetName: {
                serializedName: "properties.ruleSetName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            order: {
                serializedName: "properties.order",
                type: {
                    name: "Number"
                }
            },
            conditions: {
                serializedName: "properties.conditions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryRuleCondition"
                        }
                    }
                }
            },
            actions: {
                serializedName: "properties.actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryRuleActionAutoGenerated"
                        }
                    }
                }
            },
            matchProcessingBehavior: {
                serializedName: "properties.matchProcessingBehavior",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityPolicyListResult = {
    type: {
        name: "Composite",
        className: "SecurityPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityPolicyPropertiesParameters = {
    type: {
        name: "Composite",
        className: "SecurityPolicyPropertiesParameters",
        uberParent: "SecurityPolicyPropertiesParameters",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityPolicyUpdateParameters = {
    type: {
        name: "Composite",
        className: "SecurityPolicyUpdateParameters",
        modelProperties: {
            parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Composite",
                    className: "SecurityPolicyPropertiesParameters"
                }
            }
        }
    }
};
const SecretListResult = {
    type: {
        name: "Composite",
        className: "SecretListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Secret"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecretParameters = {
    type: {
        name: "Composite",
        className: "SecretParameters",
        uberParent: "SecretParameters",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ValidateSecretInput = {
    type: {
        name: "Composite",
        className: "ValidateSecretInput",
        modelProperties: {
            secretType: {
                serializedName: "secretType",
                required: true,
                type: {
                    name: "String"
                }
            },
            secretSource: {
                serializedName: "secretSource",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            },
            secretVersion: {
                serializedName: "secretVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ValidateSecretOutput = {
    type: {
        name: "Composite",
        className: "ValidateSecretOutput",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricsResponse = {
    type: {
        name: "Composite",
        className: "MetricsResponse",
        modelProperties: {
            dateTimeBegin: {
                serializedName: "dateTimeBegin",
                type: {
                    name: "DateTime"
                }
            },
            dateTimeEnd: {
                serializedName: "dateTimeEnd",
                type: {
                    name: "DateTime"
                }
            },
            granularity: {
                serializedName: "granularity",
                type: {
                    name: "String"
                }
            },
            series: {
                serializedName: "series",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricsResponseSeriesItem"
                        }
                    }
                }
            }
        }
    }
};
const MetricsResponseSeriesItem = {
    type: {
        name: "Composite",
        className: "MetricsResponseSeriesItem",
        modelProperties: {
            metric: {
                serializedName: "metric",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            groups: {
                serializedName: "groups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricsResponseSeriesPropertiesItemsItem"
                        }
                    }
                }
            },
            data: {
                serializedName: "data",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Components1Gs0LlpSchemasMetricsresponsePropertiesSeriesItemsPropertiesDataItems"
                        }
                    }
                }
            }
        }
    }
};
const MetricsResponseSeriesPropertiesItemsItem = {
    type: {
        name: "Composite",
        className: "MetricsResponseSeriesPropertiesItemsItem",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Components1Gs0LlpSchemasMetricsresponsePropertiesSeriesItemsPropertiesDataItems = {
    type: {
        name: "Composite",
        className: "Components1Gs0LlpSchemasMetricsresponsePropertiesSeriesItemsPropertiesDataItems",
        modelProperties: {
            dateTime: {
                serializedName: "dateTime",
                type: {
                    name: "DateTime"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const RankingsResponse = {
    type: {
        name: "Composite",
        className: "RankingsResponse",
        modelProperties: {
            dateTimeBegin: {
                serializedName: "dateTimeBegin",
                type: {
                    name: "DateTime"
                }
            },
            dateTimeEnd: {
                serializedName: "dateTimeEnd",
                type: {
                    name: "DateTime"
                }
            },
            tables: {
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RankingsResponseTablesItem"
                        }
                    }
                }
            }
        }
    }
};
const RankingsResponseTablesItem = {
    type: {
        name: "Composite",
        className: "RankingsResponseTablesItem",
        modelProperties: {
            ranking: {
                serializedName: "ranking",
                type: {
                    name: "String"
                }
            },
            data: {
                serializedName: "data",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RankingsResponseTablesPropertiesItemsItem"
                        }
                    }
                }
            }
        }
    }
};
const RankingsResponseTablesPropertiesItemsItem = {
    type: {
        name: "Composite",
        className: "RankingsResponseTablesPropertiesItemsItem",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            metrics: {
                serializedName: "metrics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RankingsResponseTablesPropertiesItemsMetricsItem"
                        }
                    }
                }
            }
        }
    }
};
const RankingsResponseTablesPropertiesItemsMetricsItem = {
    type: {
        name: "Composite",
        className: "RankingsResponseTablesPropertiesItemsMetricsItem",
        modelProperties: {
            metric: {
                serializedName: "metric",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Number"
                }
            },
            percentage: {
                serializedName: "percentage",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ContinentsResponse = {
    type: {
        name: "Composite",
        className: "ContinentsResponse",
        modelProperties: {
            continents: {
                serializedName: "continents",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContinentsResponseContinentsItem"
                        }
                    }
                }
            },
            countryOrRegions: {
                serializedName: "countryOrRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContinentsResponseCountryOrRegionsItem"
                        }
                    }
                }
            }
        }
    }
};
const ContinentsResponseContinentsItem = {
    type: {
        name: "Composite",
        className: "ContinentsResponseContinentsItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContinentsResponseCountryOrRegionsItem = {
    type: {
        name: "Composite",
        className: "ContinentsResponseCountryOrRegionsItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            continentId: {
                serializedName: "continentId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourcesResponse = {
    type: {
        name: "Composite",
        className: "ResourcesResponse",
        modelProperties: {
            endpoints: {
                serializedName: "endpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourcesResponseEndpointsItem"
                        }
                    }
                }
            },
            customDomains: {
                serializedName: "customDomains",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourcesResponseCustomDomainsItem"
                        }
                    }
                }
            }
        }
    }
};
const ResourcesResponseEndpointsItem = {
    type: {
        name: "Composite",
        className: "ResourcesResponseEndpointsItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            history: {
                serializedName: "history",
                type: {
                    name: "Boolean"
                }
            },
            customDomains: {
                serializedName: "customDomains",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourcesResponseEndpointsPropertiesItemsItem"
                        }
                    }
                }
            }
        }
    }
};
const ResourcesResponseEndpointsPropertiesItemsItem = {
    type: {
        name: "Composite",
        className: "ResourcesResponseEndpointsPropertiesItemsItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            endpointId: {
                serializedName: "endpointId",
                type: {
                    name: "String"
                }
            },
            history: {
                serializedName: "history",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ResourcesResponseCustomDomainsItem = {
    type: {
        name: "Composite",
        className: "ResourcesResponseCustomDomainsItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            endpointId: {
                serializedName: "endpointId",
                type: {
                    name: "String"
                }
            },
            history: {
                serializedName: "history",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const WafMetricsResponse = {
    type: {
        name: "Composite",
        className: "WafMetricsResponse",
        modelProperties: {
            dateTimeBegin: {
                serializedName: "dateTimeBegin",
                type: {
                    name: "DateTime"
                }
            },
            dateTimeEnd: {
                serializedName: "dateTimeEnd",
                type: {
                    name: "DateTime"
                }
            },
            granularity: {
                serializedName: "granularity",
                type: {
                    name: "String"
                }
            },
            series: {
                serializedName: "series",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WafMetricsResponseSeriesItem"
                        }
                    }
                }
            }
        }
    }
};
const WafMetricsResponseSeriesItem = {
    type: {
        name: "Composite",
        className: "WafMetricsResponseSeriesItem",
        modelProperties: {
            metric: {
                serializedName: "metric",
                type: {
                    name: "String"
                }
            },
            unit: {
                defaultValue: "count",
                isConstant: true,
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            groups: {
                serializedName: "groups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WafMetricsResponseSeriesPropertiesItemsItem"
                        }
                    }
                }
            },
            data: {
                serializedName: "data",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Components18OrqelSchemasWafmetricsresponsePropertiesSeriesItemsPropertiesDataItems"
                        }
                    }
                }
            }
        }
    }
};
const WafMetricsResponseSeriesPropertiesItemsItem = {
    type: {
        name: "Composite",
        className: "WafMetricsResponseSeriesPropertiesItemsItem",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Components18OrqelSchemasWafmetricsresponsePropertiesSeriesItemsPropertiesDataItems = {
    type: {
        name: "Composite",
        className: "Components18OrqelSchemasWafmetricsresponsePropertiesSeriesItemsPropertiesDataItems",
        modelProperties: {
            dateTime: {
                serializedName: "dateTime",
                type: {
                    name: "DateTime"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const WafRankingsResponse = {
    type: {
        name: "Composite",
        className: "WafRankingsResponse",
        modelProperties: {
            dateTimeBegin: {
                serializedName: "dateTimeBegin",
                type: {
                    name: "DateTime"
                }
            },
            dateTimeEnd: {
                serializedName: "dateTimeEnd",
                type: {
                    name: "DateTime"
                }
            },
            groups: {
                serializedName: "groups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            data: {
                serializedName: "data",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WafRankingsResponseDataItem"
                        }
                    }
                }
            }
        }
    }
};
const WafRankingsResponseDataItem = {
    type: {
        name: "Composite",
        className: "WafRankingsResponseDataItem",
        modelProperties: {
            groupValues: {
                serializedName: "groupValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            metrics: {
                serializedName: "metrics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComponentsKpo1PjSchemasWafrankingsresponsePropertiesDataItemsPropertiesMetricsItems"
                        }
                    }
                }
            }
        }
    }
};
const ComponentsKpo1PjSchemasWafrankingsresponsePropertiesDataItemsPropertiesMetricsItems = {
    type: {
        name: "Composite",
        className: "ComponentsKpo1PjSchemasWafrankingsresponsePropertiesDataItemsPropertiesMetricsItems",
        modelProperties: {
            metric: {
                serializedName: "metric",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Number"
                }
            },
            percentage: {
                serializedName: "percentage",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ProfileListResult = {
    type: {
        name: "Composite",
        className: "ProfileListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Profile"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ProfileUpdateParameters = {
    type: {
        name: "Composite",
        className: "ProfileUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            originResponseTimeoutSeconds: {
                constraints: {
                    InclusiveMinimum: 16
                },
                serializedName: "properties.originResponseTimeoutSeconds",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SsoUri = {
    type: {
        name: "Composite",
        className: "SsoUri",
        modelProperties: {
            ssoUriValue: {
                serializedName: "ssoUriValue",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SupportedOptimizationTypesListResult = {
    type: {
        name: "Composite",
        className: "SupportedOptimizationTypesListResult",
        modelProperties: {
            supportedOptimizationTypes: {
                serializedName: "supportedOptimizationTypes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ResourceUsageListResult = {
    type: {
        name: "Composite",
        className: "ResourceUsageListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceUsage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceUsage = {
    type: {
        name: "Composite",
        className: "ResourceUsage",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const EndpointListResult = {
    type: {
        name: "Composite",
        className: "EndpointListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Endpoint"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeepCreatedOrigin = {
    type: {
        name: "Composite",
        className: "DeepCreatedOrigin",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String"
                }
            },
            httpPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.httpPort",
                type: {
                    name: "Number"
                }
            },
            httpsPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.httpsPort",
                type: {
                    name: "Number"
                }
            },
            originHostHeader: {
                serializedName: "properties.originHostHeader",
                type: {
                    name: "String"
                }
            },
            priority: {
                constraints: {
                    InclusiveMaximum: 5,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            },
            weight: {
                constraints: {
                    InclusiveMaximum: 1000,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.weight",
                type: {
                    name: "Number"
                }
            },
            enabled: {
                serializedName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            },
            privateLinkAlias: {
                serializedName: "properties.privateLinkAlias",
                type: {
                    name: "String"
                }
            },
            privateLinkResourceId: {
                serializedName: "properties.privateLinkResourceId",
                type: {
                    name: "String"
                }
            },
            privateLinkLocation: {
                serializedName: "properties.privateLinkLocation",
                type: {
                    name: "String"
                }
            },
            privateLinkApprovalMessage: {
                serializedName: "properties.privateLinkApprovalMessage",
                type: {
                    name: "String"
                }
            },
            privateEndpointStatus: {
                serializedName: "properties.privateEndpointStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeepCreatedOriginGroup = {
    type: {
        name: "Composite",
        className: "DeepCreatedOriginGroup",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            healthProbeSettings: {
                serializedName: "properties.healthProbeSettings",
                type: {
                    name: "Composite",
                    className: "HealthProbeParameters"
                }
            },
            origins: {
                serializedName: "properties.origins",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceReference"
                        }
                    }
                }
            },
            trafficRestorationTimeToHealedOrNewEndpointsInMinutes: {
                constraints: {
                    InclusiveMaximum: 50,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.trafficRestorationTimeToHealedOrNewEndpointsInMinutes",
                type: {
                    name: "Number"
                }
            },
            responseBasedOriginErrorDetectionSettings: {
                serializedName: "properties.responseBasedOriginErrorDetectionSettings",
                type: {
                    name: "Composite",
                    className: "ResponseBasedOriginErrorDetectionParameters"
                }
            }
        }
    }
};
const ResponseBasedOriginErrorDetectionParameters = {
    type: {
        name: "Composite",
        className: "ResponseBasedOriginErrorDetectionParameters",
        modelProperties: {
            responseBasedDetectedErrorTypes: {
                serializedName: "responseBasedDetectedErrorTypes",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "TcpErrorsOnly", "TcpAndHttpErrors"]
                }
            },
            responseBasedFailoverThresholdPercentage: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "responseBasedFailoverThresholdPercentage",
                type: {
                    name: "Number"
                }
            },
            httpErrorRanges: {
                serializedName: "httpErrorRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HttpErrorRangeParameters"
                        }
                    }
                }
            }
        }
    }
};
const HttpErrorRangeParameters = {
    type: {
        name: "Composite",
        className: "HttpErrorRangeParameters",
        modelProperties: {
            begin: {
                constraints: {
                    InclusiveMaximum: 999,
                    InclusiveMinimum: 100
                },
                serializedName: "begin",
                type: {
                    name: "Number"
                }
            },
            end: {
                constraints: {
                    InclusiveMaximum: 999,
                    InclusiveMinimum: 100
                },
                serializedName: "end",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DeepCreatedCustomDomain = {
    type: {
        name: "Composite",
        className: "DeepCreatedCustomDomain",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String"
                }
            },
            validationData: {
                serializedName: "properties.validationData",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EndpointPropertiesUpdateParameters = {
    type: {
        name: "Composite",
        className: "EndpointPropertiesUpdateParameters",
        modelProperties: {
            originPath: {
                serializedName: "originPath",
                type: {
                    name: "String"
                }
            },
            contentTypesToCompress: {
                serializedName: "contentTypesToCompress",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            originHostHeader: {
                serializedName: "originHostHeader",
                type: {
                    name: "String"
                }
            },
            isCompressionEnabled: {
                serializedName: "isCompressionEnabled",
                type: {
                    name: "Boolean"
                }
            },
            isHttpAllowed: {
                serializedName: "isHttpAllowed",
                type: {
                    name: "Boolean"
                }
            },
            isHttpsAllowed: {
                serializedName: "isHttpsAllowed",
                type: {
                    name: "Boolean"
                }
            },
            queryStringCachingBehavior: {
                serializedName: "queryStringCachingBehavior",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "IgnoreQueryString",
                        "BypassCaching",
                        "UseQueryString",
                        "NotSet"
                    ]
                }
            },
            optimizationType: {
                serializedName: "optimizationType",
                type: {
                    name: "String"
                }
            },
            probePath: {
                serializedName: "probePath",
                type: {
                    name: "String"
                }
            },
            geoFilters: {
                serializedName: "geoFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GeoFilter"
                        }
                    }
                }
            },
            defaultOriginGroup: {
                serializedName: "defaultOriginGroup",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            },
            urlSigningKeys: {
                serializedName: "urlSigningKeys",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UrlSigningKey"
                        }
                    }
                }
            },
            deliveryPolicy: {
                serializedName: "deliveryPolicy",
                type: {
                    name: "Composite",
                    className: "EndpointPropertiesUpdateParametersDeliveryPolicy"
                }
            },
            webApplicationFirewallPolicyLink: {
                serializedName: "webApplicationFirewallPolicyLink",
                type: {
                    name: "Composite",
                    className: "EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink"
                }
            }
        }
    }
};
const GeoFilter = {
    type: {
        name: "Composite",
        className: "GeoFilter",
        modelProperties: {
            relativePath: {
                serializedName: "relativePath",
                required: true,
                type: {
                    name: "String"
                }
            },
            action: {
                serializedName: "action",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Block", "Allow"]
                }
            },
            countryCodes: {
                serializedName: "countryCodes",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const UrlSigningKey = {
    type: {
        name: "Composite",
        className: "UrlSigningKey",
        modelProperties: {
            keyId: {
                serializedName: "keyId",
                required: true,
                type: {
                    name: "String"
                }
            },
            keySourceParameters: {
                serializedName: "keySourceParameters",
                type: {
                    name: "Composite",
                    className: "KeyVaultSigningKeyParameters"
                }
            }
        }
    }
};
const KeyVaultSigningKeyParameters = {
    type: {
        name: "Composite",
        className: "KeyVaultSigningKeyParameters",
        modelProperties: {
            typeName: {
                defaultValue: "KeyVaultSigningKeyParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            subscriptionId: {
                serializedName: "subscriptionId",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceGroupName: {
                serializedName: "resourceGroupName",
                required: true,
                type: {
                    name: "String"
                }
            },
            vaultName: {
                serializedName: "vaultName",
                required: true,
                type: {
                    name: "String"
                }
            },
            secretName: {
                serializedName: "secretName",
                required: true,
                type: {
                    name: "String"
                }
            },
            secretVersion: {
                serializedName: "secretVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EndpointPropertiesUpdateParametersDeliveryPolicy = {
    type: {
        name: "Composite",
        className: "EndpointPropertiesUpdateParametersDeliveryPolicy",
        modelProperties: {
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            rules: {
                serializedName: "rules",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryRule"
                        }
                    }
                }
            }
        }
    }
};
const DeliveryRule = {
    type: {
        name: "Composite",
        className: "DeliveryRule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            order: {
                serializedName: "order",
                required: true,
                type: {
                    name: "Number"
                }
            },
            conditions: {
                serializedName: "conditions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryRuleCondition"
                        }
                    }
                }
            },
            actions: {
                serializedName: "actions",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryRuleActionAutoGenerated"
                        }
                    }
                }
            }
        }
    }
};
const EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink = {
    type: {
        name: "Composite",
        className: "EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EndpointUpdateParameters = {
    type: {
        name: "Composite",
        className: "EndpointUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            originPath: {
                serializedName: "properties.originPath",
                type: {
                    name: "String"
                }
            },
            contentTypesToCompress: {
                serializedName: "properties.contentTypesToCompress",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            originHostHeader: {
                serializedName: "properties.originHostHeader",
                type: {
                    name: "String"
                }
            },
            isCompressionEnabled: {
                serializedName: "properties.isCompressionEnabled",
                type: {
                    name: "Boolean"
                }
            },
            isHttpAllowed: {
                serializedName: "properties.isHttpAllowed",
                type: {
                    name: "Boolean"
                }
            },
            isHttpsAllowed: {
                serializedName: "properties.isHttpsAllowed",
                type: {
                    name: "Boolean"
                }
            },
            queryStringCachingBehavior: {
                serializedName: "properties.queryStringCachingBehavior",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "IgnoreQueryString",
                        "BypassCaching",
                        "UseQueryString",
                        "NotSet"
                    ]
                }
            },
            optimizationType: {
                serializedName: "properties.optimizationType",
                type: {
                    name: "String"
                }
            },
            probePath: {
                serializedName: "properties.probePath",
                type: {
                    name: "String"
                }
            },
            geoFilters: {
                serializedName: "properties.geoFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GeoFilter"
                        }
                    }
                }
            },
            defaultOriginGroup: {
                serializedName: "properties.defaultOriginGroup",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            },
            urlSigningKeys: {
                serializedName: "properties.urlSigningKeys",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UrlSigningKey"
                        }
                    }
                }
            },
            deliveryPolicy: {
                serializedName: "properties.deliveryPolicy",
                type: {
                    name: "Composite",
                    className: "EndpointPropertiesUpdateParametersDeliveryPolicy"
                }
            },
            webApplicationFirewallPolicyLink: {
                serializedName: "properties.webApplicationFirewallPolicyLink",
                type: {
                    name: "Composite",
                    className: "EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink"
                }
            }
        }
    }
};
const PurgeParameters = {
    type: {
        name: "Composite",
        className: "PurgeParameters",
        modelProperties: {
            contentPaths: {
                serializedName: "contentPaths",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const LoadParameters = {
    type: {
        name: "Composite",
        className: "LoadParameters",
        modelProperties: {
            contentPaths: {
                serializedName: "contentPaths",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const OriginListResult = {
    type: {
        name: "Composite",
        className: "OriginListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Origin"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OriginUpdatePropertiesParameters = {
    type: {
        name: "Composite",
        className: "OriginUpdatePropertiesParameters",
        modelProperties: {
            hostName: {
                serializedName: "hostName",
                type: {
                    name: "String"
                }
            },
            httpPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "httpPort",
                type: {
                    name: "Number"
                }
            },
            httpsPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "httpsPort",
                type: {
                    name: "Number"
                }
            },
            originHostHeader: {
                serializedName: "originHostHeader",
                type: {
                    name: "String"
                }
            },
            priority: {
                constraints: {
                    InclusiveMaximum: 5,
                    InclusiveMinimum: 1
                },
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            },
            weight: {
                constraints: {
                    InclusiveMaximum: 1000,
                    InclusiveMinimum: 1
                },
                serializedName: "weight",
                type: {
                    name: "Number"
                }
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            privateLinkAlias: {
                serializedName: "privateLinkAlias",
                type: {
                    name: "String"
                }
            },
            privateLinkResourceId: {
                serializedName: "privateLinkResourceId",
                type: {
                    name: "String"
                }
            },
            privateLinkLocation: {
                serializedName: "privateLinkLocation",
                type: {
                    name: "String"
                }
            },
            privateLinkApprovalMessage: {
                serializedName: "privateLinkApprovalMessage",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OriginUpdateParameters = {
    type: {
        name: "Composite",
        className: "OriginUpdateParameters",
        modelProperties: {
            hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String"
                }
            },
            httpPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.httpPort",
                type: {
                    name: "Number"
                }
            },
            httpsPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.httpsPort",
                type: {
                    name: "Number"
                }
            },
            originHostHeader: {
                serializedName: "properties.originHostHeader",
                type: {
                    name: "String"
                }
            },
            priority: {
                constraints: {
                    InclusiveMaximum: 5,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            },
            weight: {
                constraints: {
                    InclusiveMaximum: 1000,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.weight",
                type: {
                    name: "Number"
                }
            },
            enabled: {
                serializedName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            },
            privateLinkAlias: {
                serializedName: "properties.privateLinkAlias",
                type: {
                    name: "String"
                }
            },
            privateLinkResourceId: {
                serializedName: "properties.privateLinkResourceId",
                type: {
                    name: "String"
                }
            },
            privateLinkLocation: {
                serializedName: "properties.privateLinkLocation",
                type: {
                    name: "String"
                }
            },
            privateLinkApprovalMessage: {
                serializedName: "properties.privateLinkApprovalMessage",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OriginGroupListResult = {
    type: {
        name: "Composite",
        className: "OriginGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OriginGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OriginGroupUpdatePropertiesParameters = {
    type: {
        name: "Composite",
        className: "OriginGroupUpdatePropertiesParameters",
        modelProperties: {
            healthProbeSettings: {
                serializedName: "healthProbeSettings",
                type: {
                    name: "Composite",
                    className: "HealthProbeParameters"
                }
            },
            origins: {
                serializedName: "origins",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceReference"
                        }
                    }
                }
            },
            trafficRestorationTimeToHealedOrNewEndpointsInMinutes: {
                constraints: {
                    InclusiveMaximum: 50,
                    InclusiveMinimum: 0
                },
                serializedName: "trafficRestorationTimeToHealedOrNewEndpointsInMinutes",
                type: {
                    name: "Number"
                }
            },
            responseBasedOriginErrorDetectionSettings: {
                serializedName: "responseBasedOriginErrorDetectionSettings",
                type: {
                    name: "Composite",
                    className: "ResponseBasedOriginErrorDetectionParameters"
                }
            }
        }
    }
};
const OriginGroupUpdateParameters = {
    type: {
        name: "Composite",
        className: "OriginGroupUpdateParameters",
        modelProperties: {
            healthProbeSettings: {
                serializedName: "properties.healthProbeSettings",
                type: {
                    name: "Composite",
                    className: "HealthProbeParameters"
                }
            },
            origins: {
                serializedName: "properties.origins",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceReference"
                        }
                    }
                }
            },
            trafficRestorationTimeToHealedOrNewEndpointsInMinutes: {
                constraints: {
                    InclusiveMaximum: 50,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.trafficRestorationTimeToHealedOrNewEndpointsInMinutes",
                type: {
                    name: "Number"
                }
            },
            responseBasedOriginErrorDetectionSettings: {
                serializedName: "properties.responseBasedOriginErrorDetectionSettings",
                type: {
                    name: "Composite",
                    className: "ResponseBasedOriginErrorDetectionParameters"
                }
            }
        }
    }
};
const CustomDomainListResult = {
    type: {
        name: "Composite",
        className: "CustomDomainListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomDomain"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomDomainHttpsParameters = {
    type: {
        name: "Composite",
        className: "CustomDomainHttpsParameters",
        uberParent: "CustomDomainHttpsParameters",
        polymorphicDiscriminator: {
            serializedName: "certificateSource",
            clientName: "certificateSource"
        },
        modelProperties: {
            certificateSource: {
                serializedName: "certificateSource",
                required: true,
                type: {
                    name: "String"
                }
            },
            protocolType: {
                serializedName: "protocolType",
                required: true,
                type: {
                    name: "String"
                }
            },
            minimumTlsVersion: {
                serializedName: "minimumTlsVersion",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "TLS10", "TLS12"]
                }
            }
        }
    }
};
const CustomDomainParameters = {
    type: {
        name: "Composite",
        className: "CustomDomainParameters",
        modelProperties: {
            hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityInput = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityInput",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ValidateProbeInput = {
    type: {
        name: "Composite",
        className: "ValidateProbeInput",
        modelProperties: {
            probeURL: {
                serializedName: "probeURL",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ValidateProbeOutput = {
    type: {
        name: "Composite",
        className: "ValidateProbeOutput",
        modelProperties: {
            isValid: {
                serializedName: "isValid",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            errorCode: {
                serializedName: "errorCode",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationsListResult = {
    type: {
        name: "Composite",
        className: "OperationsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            serviceSpecification: {
                serializedName: "properties.serviceSpecification",
                type: {
                    name: "Composite",
                    className: "ServiceSpecification"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceSpecification = {
    type: {
        name: "Composite",
        className: "ServiceSpecification",
        modelProperties: {
            logSpecifications: {
                serializedName: "logSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LogSpecification"
                        }
                    }
                }
            },
            metricSpecifications: {
                serializedName: "metricSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecification"
                        }
                    }
                }
            }
        }
    }
};
const LogSpecification = {
    type: {
        name: "Composite",
        className: "LogSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            blobDuration: {
                serializedName: "blobDuration",
                type: {
                    name: "String"
                }
            },
            logFilterPattern: {
                serializedName: "logFilterPattern",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricSpecification = {
    type: {
        name: "Composite",
        className: "MetricSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                type: {
                    name: "String"
                }
            },
            availabilities: {
                serializedName: "availabilities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricAvailability"
                        }
                    }
                }
            },
            supportedTimeGrainTypes: {
                serializedName: "supportedTimeGrainTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DimensionProperties"
                        }
                    }
                }
            },
            fillGapWithZero: {
                serializedName: "fillGapWithZero",
                type: {
                    name: "Boolean"
                }
            },
            metricFilterPattern: {
                serializedName: "metricFilterPattern",
                type: {
                    name: "String"
                }
            },
            isInternal: {
                serializedName: "isInternal",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const MetricAvailability = {
    type: {
        name: "Composite",
        className: "MetricAvailability",
        modelProperties: {
            timeGrain: {
                serializedName: "timeGrain",
                type: {
                    name: "String"
                }
            },
            blobDuration: {
                serializedName: "blobDuration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DimensionProperties = {
    type: {
        name: "Composite",
        className: "DimensionProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            internalName: {
                serializedName: "internalName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EdgenodeResult = {
    type: {
        name: "Composite",
        className: "EdgenodeResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EdgeNode"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IpAddressGroup = {
    type: {
        name: "Composite",
        className: "IpAddressGroup",
        modelProperties: {
            deliveryRegion: {
                serializedName: "deliveryRegion",
                type: {
                    name: "String"
                }
            },
            ipv4Addresses: {
                serializedName: "ipv4Addresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CidrIpAddress"
                        }
                    }
                }
            },
            ipv6Addresses: {
                serializedName: "ipv6Addresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CidrIpAddress"
                        }
                    }
                }
            }
        }
    }
};
const CidrIpAddress = {
    type: {
        name: "Composite",
        className: "CidrIpAddress",
        modelProperties: {
            baseIpAddress: {
                serializedName: "baseIpAddress",
                type: {
                    name: "String"
                }
            },
            prefixLength: {
                serializedName: "prefixLength",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CdnWebApplicationFirewallPolicyList = {
    type: {
        name: "Composite",
        className: "CdnWebApplicationFirewallPolicyList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CdnWebApplicationFirewallPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicySettings = {
    type: {
        name: "Composite",
        className: "PolicySettings",
        modelProperties: {
            enabledState: {
                serializedName: "enabledState",
                type: {
                    name: "String"
                }
            },
            mode: {
                serializedName: "mode",
                type: {
                    name: "String"
                }
            },
            defaultRedirectUrl: {
                serializedName: "defaultRedirectUrl",
                type: {
                    name: "String"
                }
            },
            defaultCustomBlockResponseStatusCode: {
                serializedName: "defaultCustomBlockResponseStatusCode",
                type: {
                    name: "Number"
                }
            },
            defaultCustomBlockResponseBody: {
                constraints: {
                    Pattern: new RegExp("^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$")
                },
                serializedName: "defaultCustomBlockResponseBody",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RateLimitRuleList = {
    type: {
        name: "Composite",
        className: "RateLimitRuleList",
        modelProperties: {
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RateLimitRule"
                        }
                    }
                }
            }
        }
    }
};
const CustomRule = {
    type: {
        name: "Composite",
        className: "CustomRule",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            enabledState: {
                serializedName: "enabledState",
                type: {
                    name: "String"
                }
            },
            priority: {
                constraints: {
                    InclusiveMaximum: 1000,
                    InclusiveMinimum: 0
                },
                serializedName: "priority",
                required: true,
                type: {
                    name: "Number"
                }
            },
            matchConditions: {
                serializedName: "matchConditions",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MatchCondition"
                        }
                    }
                }
            },
            action: {
                serializedName: "action",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MatchCondition = {
    type: {
        name: "Composite",
        className: "MatchCondition",
        modelProperties: {
            matchVariable: {
                serializedName: "matchVariable",
                required: true,
                type: {
                    name: "String"
                }
            },
            selector: {
                serializedName: "selector",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValue: {
                serializedName: "matchValue",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const CustomRuleList = {
    type: {
        name: "Composite",
        className: "CustomRuleList",
        modelProperties: {
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomRule"
                        }
                    }
                }
            }
        }
    }
};
const ManagedRuleSetList = {
    type: {
        name: "Composite",
        className: "ManagedRuleSetList",
        modelProperties: {
            managedRuleSets: {
                serializedName: "managedRuleSets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleSet"
                        }
                    }
                }
            }
        }
    }
};
const ManagedRuleSet = {
    type: {
        name: "Composite",
        className: "ManagedRuleSet",
        modelProperties: {
            ruleSetType: {
                serializedName: "ruleSetType",
                required: true,
                type: {
                    name: "String"
                }
            },
            ruleSetVersion: {
                serializedName: "ruleSetVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            anomalyScore: {
                constraints: {
                    InclusiveMaximum: 20,
                    InclusiveMinimum: 0
                },
                serializedName: "anomalyScore",
                type: {
                    name: "Number"
                }
            },
            ruleGroupOverrides: {
                serializedName: "ruleGroupOverrides",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleGroupOverride"
                        }
                    }
                }
            }
        }
    }
};
const ManagedRuleGroupOverride = {
    type: {
        name: "Composite",
        className: "ManagedRuleGroupOverride",
        modelProperties: {
            ruleGroupName: {
                serializedName: "ruleGroupName",
                required: true,
                type: {
                    name: "String"
                }
            },
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleOverride"
                        }
                    }
                }
            }
        }
    }
};
const ManagedRuleOverride = {
    type: {
        name: "Composite",
        className: "ManagedRuleOverride",
        modelProperties: {
            ruleId: {
                serializedName: "ruleId",
                required: true,
                type: {
                    name: "String"
                }
            },
            enabledState: {
                serializedName: "enabledState",
                type: {
                    name: "String"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CdnEndpoint = {
    type: {
        name: "Composite",
        className: "CdnEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CdnWebApplicationFirewallPolicyPatchParameters = {
    type: {
        name: "Composite",
        className: "CdnWebApplicationFirewallPolicyPatchParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ManagedRuleSetDefinitionList = {
    type: {
        name: "Composite",
        className: "ManagedRuleSetDefinitionList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleSetDefinition"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedRuleGroupDefinition = {
    type: {
        name: "Composite",
        className: "ManagedRuleGroupDefinition",
        modelProperties: {
            ruleGroupName: {
                serializedName: "ruleGroupName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            rules: {
                serializedName: "rules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleDefinition"
                        }
                    }
                }
            }
        }
    }
};
const ManagedRuleDefinition = {
    type: {
        name: "Composite",
        className: "ManagedRuleDefinition",
        modelProperties: {
            ruleId: {
                serializedName: "ruleId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Certificate = {
    type: {
        name: "Composite",
        className: "Certificate",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            subject: {
                serializedName: "subject",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            expirationDate: {
                serializedName: "expirationDate",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityPolicyWebApplicationFirewallAssociation = {
    type: {
        name: "Composite",
        className: "SecurityPolicyWebApplicationFirewallAssociation",
        modelProperties: {
            domains: {
                serializedName: "domains",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ActivatedResourceReference"
                        }
                    }
                }
            },
            patternsToMatch: {
                serializedName: "patternsToMatch",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ValidationToken = {
    type: {
        name: "Composite",
        className: "ValidationToken",
        modelProperties: {
            token: {
                serializedName: "token",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RemoteAddressMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "RemoteAddressMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleRemoteAddressConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RequestMethodMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "RequestMethodMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleRequestMethodConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const QueryStringMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "QueryStringMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleQueryStringConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PostArgsMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "PostArgsMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRulePostArgsConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            selector: {
                serializedName: "selector",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RequestUriMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "RequestUriMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleRequestUriConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RequestHeaderMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "RequestHeaderMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleRequestHeaderConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            selector: {
                serializedName: "selector",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RequestBodyMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "RequestBodyMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleRequestBodyConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RequestSchemeMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "RequestSchemeMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleRequestSchemeConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                defaultValue: "Equal",
                isConstant: true,
                serializedName: "operator",
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const UrlPathMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "UrlPathMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleUrlPathMatchConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const UrlFileExtensionMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "UrlFileExtensionMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleUrlFileExtensionMatchConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const UrlFileNameMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "UrlFileNameMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleUrlFilenameConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const HttpVersionMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "HttpVersionMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleHttpVersionConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const CookiesMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "CookiesMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleCookiesConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            selector: {
                serializedName: "selector",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const IsDeviceMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "IsDeviceMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleIsDeviceConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const SocketAddrMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "SocketAddrMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleSocketAddrConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ClientPortMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "ClientPortMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleClientPortConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ServerPortMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "ServerPortMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleServerPortConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const HostNameMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "HostNameMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleHostNameConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const SslProtocolMatchConditionParameters = {
    type: {
        name: "Composite",
        className: "SslProtocolMatchConditionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleSslProtocolConditionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const UrlRedirectActionParameters = {
    type: {
        name: "Composite",
        className: "UrlRedirectActionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleUrlRedirectActionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            redirectType: {
                serializedName: "redirectType",
                required: true,
                type: {
                    name: "String"
                }
            },
            destinationProtocol: {
                serializedName: "destinationProtocol",
                type: {
                    name: "String"
                }
            },
            customPath: {
                serializedName: "customPath",
                type: {
                    name: "String"
                }
            },
            customHostname: {
                serializedName: "customHostname",
                type: {
                    name: "String"
                }
            },
            customQueryString: {
                serializedName: "customQueryString",
                type: {
                    name: "String"
                }
            },
            customFragment: {
                serializedName: "customFragment",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UrlSigningActionParameters = {
    type: {
        name: "Composite",
        className: "UrlSigningActionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleUrlSigningActionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            algorithm: {
                serializedName: "algorithm",
                type: {
                    name: "String"
                }
            },
            parameterNameOverride: {
                serializedName: "parameterNameOverride",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UrlSigningParamIdentifier"
                        }
                    }
                }
            }
        }
    }
};
const UrlSigningParamIdentifier = {
    type: {
        name: "Composite",
        className: "UrlSigningParamIdentifier",
        modelProperties: {
            paramIndicator: {
                serializedName: "paramIndicator",
                required: true,
                type: {
                    name: "String"
                }
            },
            paramName: {
                serializedName: "paramName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OriginGroupOverrideActionParameters = {
    type: {
        name: "Composite",
        className: "OriginGroupOverrideActionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleOriginGroupOverrideActionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            originGroup: {
                serializedName: "originGroup",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }
        }
    }
};
const UrlRewriteActionParameters = {
    type: {
        name: "Composite",
        className: "UrlRewriteActionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleUrlRewriteActionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            sourcePattern: {
                serializedName: "sourcePattern",
                required: true,
                type: {
                    name: "String"
                }
            },
            destination: {
                serializedName: "destination",
                required: true,
                type: {
                    name: "String"
                }
            },
            preserveUnmatchedPath: {
                serializedName: "preserveUnmatchedPath",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const HeaderActionParameters = {
    type: {
        name: "Composite",
        className: "HeaderActionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleHeaderActionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            headerAction: {
                serializedName: "headerAction",
                required: true,
                type: {
                    name: "String"
                }
            },
            headerName: {
                serializedName: "headerName",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CacheExpirationActionParameters = {
    type: {
        name: "Composite",
        className: "CacheExpirationActionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleCacheExpirationActionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            cacheBehavior: {
                serializedName: "cacheBehavior",
                required: true,
                type: {
                    name: "String"
                }
            },
            cacheType: {
                serializedName: "cacheType",
                required: true,
                type: {
                    name: "String"
                }
            },
            cacheDuration: {
                serializedName: "cacheDuration",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CacheKeyQueryStringActionParameters = {
    type: {
        name: "Composite",
        className: "CacheKeyQueryStringActionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleCacheKeyQueryStringBehaviorActionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            queryStringBehavior: {
                serializedName: "queryStringBehavior",
                required: true,
                type: {
                    name: "String"
                }
            },
            queryParameters: {
                serializedName: "queryParameters",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RouteConfigurationOverrideActionParameters = {
    type: {
        name: "Composite",
        className: "RouteConfigurationOverrideActionParameters",
        modelProperties: {
            typeName: {
                defaultValue: "DeliveryRuleRouteConfigurationOverrideActionParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            originGroupOverride: {
                serializedName: "originGroupOverride",
                type: {
                    name: "Composite",
                    className: "OriginGroupOverride"
                }
            },
            cacheConfiguration: {
                serializedName: "cacheConfiguration",
                type: {
                    name: "Composite",
                    className: "CacheConfiguration"
                }
            }
        }
    }
};
const OriginGroupOverride = {
    type: {
        name: "Composite",
        className: "OriginGroupOverride",
        modelProperties: {
            originGroup: {
                serializedName: "originGroup",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            },
            forwardingProtocol: {
                serializedName: "forwardingProtocol",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CacheConfiguration = {
    type: {
        name: "Composite",
        className: "CacheConfiguration",
        modelProperties: {
            queryStringCachingBehavior: {
                serializedName: "queryStringCachingBehavior",
                type: {
                    name: "String"
                }
            },
            queryParameters: {
                serializedName: "queryParameters",
                type: {
                    name: "String"
                }
            },
            isCompressionEnabled: {
                serializedName: "isCompressionEnabled",
                type: {
                    name: "String"
                }
            },
            cacheBehavior: {
                serializedName: "cacheBehavior",
                type: {
                    name: "String"
                }
            },
            cacheDuration: {
                serializedName: "cacheDuration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CdnCertificateSourceParameters = {
    type: {
        name: "Composite",
        className: "CdnCertificateSourceParameters",
        modelProperties: {
            typeName: {
                defaultValue: "CdnCertificateSourceParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            certificateType: {
                serializedName: "certificateType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyVaultCertificateSourceParameters = {
    type: {
        name: "Composite",
        className: "KeyVaultCertificateSourceParameters",
        modelProperties: {
            typeName: {
                defaultValue: "KeyVaultCertificateSourceParameters",
                isConstant: true,
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            subscriptionId: {
                serializedName: "subscriptionId",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceGroupName: {
                serializedName: "resourceGroupName",
                required: true,
                type: {
                    name: "String"
                }
            },
            vaultName: {
                serializedName: "vaultName",
                required: true,
                type: {
                    name: "String"
                }
            },
            secretName: {
                serializedName: "secretName",
                required: true,
                type: {
                    name: "String"
                }
            },
            secretVersion: {
                serializedName: "secretVersion",
                type: {
                    name: "String"
                }
            },
            updateRule: {
                serializedName: "updateRule",
                required: true,
                type: {
                    name: "String"
                }
            },
            deleteRule: {
                serializedName: "deleteRule",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AFDDomainProperties = {
    type: {
        name: "Composite",
        className: "AFDDomainProperties",
        modelProperties: Object.assign(Object.assign(Object.assign({}, AFDDomainUpdatePropertiesParameters.type.modelProperties), AFDStateProperties.type.modelProperties), { domainValidationState: {
                serializedName: "domainValidationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, hostName: {
                serializedName: "hostName",
                required: true,
                type: {
                    name: "String"
                }
            }, validationProperties: {
                serializedName: "validationProperties",
                type: {
                    name: "Composite",
                    className: "DomainValidationProperties"
                }
            } })
    }
};
const AFDEndpointProperties = {
    type: {
        name: "Composite",
        className: "AFDEndpointProperties",
        modelProperties: Object.assign(Object.assign(Object.assign({}, AFDEndpointPropertiesUpdateParameters.type.modelProperties), AFDStateProperties.type.modelProperties), { hostName: {
                serializedName: "hostName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, autoGeneratedDomainNameLabelScope: {
                serializedName: "autoGeneratedDomainNameLabelScope",
                type: {
                    name: "String"
                }
            } })
    }
};
const AFDOriginGroupProperties = {
    type: {
        name: "Composite",
        className: "AFDOriginGroupProperties",
        modelProperties: Object.assign(Object.assign({}, AFDOriginGroupUpdatePropertiesParameters.type.modelProperties), AFDStateProperties.type.modelProperties)
    }
};
const AFDOriginProperties = {
    type: {
        name: "Composite",
        className: "AFDOriginProperties",
        modelProperties: Object.assign(Object.assign({}, AFDOriginUpdatePropertiesParameters.type.modelProperties), AFDStateProperties.type.modelProperties)
    }
};
const RouteProperties = {
    type: {
        name: "Composite",
        className: "RouteProperties",
        modelProperties: Object.assign(Object.assign({}, RouteUpdatePropertiesParameters.type.modelProperties), AFDStateProperties.type.modelProperties)
    }
};
const RuleSetProperties = {
    type: {
        name: "Composite",
        className: "RuleSetProperties",
        modelProperties: Object.assign(Object.assign({}, AFDStateProperties.type.modelProperties), { profileName: {
                serializedName: "profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const RuleProperties = {
    type: {
        name: "Composite",
        className: "RuleProperties",
        modelProperties: Object.assign(Object.assign({}, RuleUpdatePropertiesParameters.type.modelProperties), AFDStateProperties.type.modelProperties)
    }
};
const SecurityPolicyProperties = {
    type: {
        name: "Composite",
        className: "SecurityPolicyProperties",
        modelProperties: Object.assign(Object.assign({}, AFDStateProperties.type.modelProperties), { profileName: {
                serializedName: "profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "SecurityPolicyPropertiesParameters"
                }
            } })
    }
};
const SecretProperties = {
    type: {
        name: "Composite",
        className: "SecretProperties",
        modelProperties: Object.assign(Object.assign({}, AFDStateProperties.type.modelProperties), { profileName: {
                serializedName: "profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "SecretParameters"
                }
            } })
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const ManagedRuleSetDefinition = {
    type: {
        name: "Composite",
        className: "ManagedRuleSetDefinition",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ruleSetType: {
                serializedName: "properties.ruleSetType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ruleSetVersion: {
                serializedName: "properties.ruleSetVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ruleGroups: {
                serializedName: "properties.ruleGroups",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleGroupDefinition"
                        }
                    }
                }
            } })
    }
};
const DeliveryRuleRemoteAddressCondition = {
    serializedName: "RemoteAddress",
    type: {
        name: "Composite",
        className: "DeliveryRuleRemoteAddressCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "RemoteAddressMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleRequestMethodCondition = {
    serializedName: "RequestMethod",
    type: {
        name: "Composite",
        className: "DeliveryRuleRequestMethodCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "RequestMethodMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleQueryStringCondition = {
    serializedName: "QueryString",
    type: {
        name: "Composite",
        className: "DeliveryRuleQueryStringCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "QueryStringMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRulePostArgsCondition = {
    serializedName: "PostArgs",
    type: {
        name: "Composite",
        className: "DeliveryRulePostArgsCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "PostArgsMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleRequestUriCondition = {
    serializedName: "RequestUri",
    type: {
        name: "Composite",
        className: "DeliveryRuleRequestUriCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "RequestUriMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleRequestHeaderCondition = {
    serializedName: "RequestHeader",
    type: {
        name: "Composite",
        className: "DeliveryRuleRequestHeaderCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "RequestHeaderMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleRequestBodyCondition = {
    serializedName: "RequestBody",
    type: {
        name: "Composite",
        className: "DeliveryRuleRequestBodyCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "RequestBodyMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleRequestSchemeCondition = {
    serializedName: "RequestScheme",
    type: {
        name: "Composite",
        className: "DeliveryRuleRequestSchemeCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "RequestSchemeMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleUrlPathCondition = {
    serializedName: "UrlPath",
    type: {
        name: "Composite",
        className: "DeliveryRuleUrlPathCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "UrlPathMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleUrlFileExtensionCondition = {
    serializedName: "UrlFileExtension",
    type: {
        name: "Composite",
        className: "DeliveryRuleUrlFileExtensionCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "UrlFileExtensionMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleUrlFileNameCondition = {
    serializedName: "UrlFileName",
    type: {
        name: "Composite",
        className: "DeliveryRuleUrlFileNameCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "UrlFileNameMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleHttpVersionCondition = {
    serializedName: "HttpVersion",
    type: {
        name: "Composite",
        className: "DeliveryRuleHttpVersionCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "HttpVersionMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleCookiesCondition = {
    serializedName: "Cookies",
    type: {
        name: "Composite",
        className: "DeliveryRuleCookiesCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "CookiesMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleIsDeviceCondition = {
    serializedName: "IsDevice",
    type: {
        name: "Composite",
        className: "DeliveryRuleIsDeviceCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "IsDeviceMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleSocketAddrCondition = {
    serializedName: "SocketAddr",
    type: {
        name: "Composite",
        className: "DeliveryRuleSocketAddrCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "SocketAddrMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleClientPortCondition = {
    serializedName: "ClientPort",
    type: {
        name: "Composite",
        className: "DeliveryRuleClientPortCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "ClientPortMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleServerPortCondition = {
    serializedName: "ServerPort",
    type: {
        name: "Composite",
        className: "DeliveryRuleServerPortCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "ServerPortMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleHostNameCondition = {
    serializedName: "HostName",
    type: {
        name: "Composite",
        className: "DeliveryRuleHostNameCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "HostNameMatchConditionParameters"
                }
            } })
    }
};
const DeliveryRuleSslProtocolCondition = {
    serializedName: "SslProtocol",
    type: {
        name: "Composite",
        className: "DeliveryRuleSslProtocolCondition",
        uberParent: "DeliveryRuleCondition",
        polymorphicDiscriminator: DeliveryRuleCondition.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleCondition.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "SslProtocolMatchConditionParameters"
                }
            } })
    }
};
const UrlRedirectAction = {
    serializedName: "UrlRedirect",
    type: {
        name: "Composite",
        className: "UrlRedirectAction",
        uberParent: "DeliveryRuleActionAutoGenerated",
        polymorphicDiscriminator: DeliveryRuleActionAutoGenerated.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleActionAutoGenerated.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "UrlRedirectActionParameters"
                }
            } })
    }
};
const UrlSigningAction = {
    serializedName: "UrlSigning",
    type: {
        name: "Composite",
        className: "UrlSigningAction",
        uberParent: "DeliveryRuleActionAutoGenerated",
        polymorphicDiscriminator: DeliveryRuleActionAutoGenerated.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleActionAutoGenerated.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "UrlSigningActionParameters"
                }
            } })
    }
};
const OriginGroupOverrideAction = {
    serializedName: "OriginGroupOverride",
    type: {
        name: "Composite",
        className: "OriginGroupOverrideAction",
        uberParent: "DeliveryRuleActionAutoGenerated",
        polymorphicDiscriminator: DeliveryRuleActionAutoGenerated.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleActionAutoGenerated.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "OriginGroupOverrideActionParameters"
                }
            } })
    }
};
const UrlRewriteAction = {
    serializedName: "UrlRewrite",
    type: {
        name: "Composite",
        className: "UrlRewriteAction",
        uberParent: "DeliveryRuleActionAutoGenerated",
        polymorphicDiscriminator: DeliveryRuleActionAutoGenerated.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleActionAutoGenerated.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "UrlRewriteActionParameters"
                }
            } })
    }
};
const DeliveryRuleRequestHeaderAction = {
    serializedName: "ModifyRequestHeader",
    type: {
        name: "Composite",
        className: "DeliveryRuleRequestHeaderAction",
        uberParent: "DeliveryRuleActionAutoGenerated",
        polymorphicDiscriminator: DeliveryRuleActionAutoGenerated.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleActionAutoGenerated.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "HeaderActionParameters"
                }
            } })
    }
};
const DeliveryRuleResponseHeaderAction = {
    serializedName: "ModifyResponseHeader",
    type: {
        name: "Composite",
        className: "DeliveryRuleResponseHeaderAction",
        uberParent: "DeliveryRuleActionAutoGenerated",
        polymorphicDiscriminator: DeliveryRuleActionAutoGenerated.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleActionAutoGenerated.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "HeaderActionParameters"
                }
            } })
    }
};
const DeliveryRuleCacheExpirationAction = {
    serializedName: "CacheExpiration",
    type: {
        name: "Composite",
        className: "DeliveryRuleCacheExpirationAction",
        uberParent: "DeliveryRuleActionAutoGenerated",
        polymorphicDiscriminator: DeliveryRuleActionAutoGenerated.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleActionAutoGenerated.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "CacheExpirationActionParameters"
                }
            } })
    }
};
const DeliveryRuleCacheKeyQueryStringAction = {
    serializedName: "CacheKeyQueryString",
    type: {
        name: "Composite",
        className: "DeliveryRuleCacheKeyQueryStringAction",
        uberParent: "DeliveryRuleActionAutoGenerated",
        polymorphicDiscriminator: DeliveryRuleActionAutoGenerated.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleActionAutoGenerated.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "CacheKeyQueryStringActionParameters"
                }
            } })
    }
};
const DeliveryRuleRouteConfigurationOverrideAction = {
    serializedName: "RouteConfigurationOverride",
    type: {
        name: "Composite",
        className: "DeliveryRuleRouteConfigurationOverrideAction",
        uberParent: "DeliveryRuleActionAutoGenerated",
        polymorphicDiscriminator: DeliveryRuleActionAutoGenerated.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryRuleActionAutoGenerated.type.modelProperties), { parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "RouteConfigurationOverrideActionParameters"
                }
            } })
    }
};
const SecurityPolicyWebApplicationFirewallParameters = {
    serializedName: "WebApplicationFirewall",
    type: {
        name: "Composite",
        className: "SecurityPolicyWebApplicationFirewallParameters",
        uberParent: "SecurityPolicyPropertiesParameters",
        polymorphicDiscriminator: SecurityPolicyPropertiesParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SecurityPolicyPropertiesParameters.type.modelProperties), { wafPolicy: {
                serializedName: "wafPolicy",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, associations: {
                serializedName: "associations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityPolicyWebApplicationFirewallAssociation"
                        }
                    }
                }
            } })
    }
};
const UrlSigningKeyParameters = {
    serializedName: "UrlSigningKey",
    type: {
        name: "Composite",
        className: "UrlSigningKeyParameters",
        uberParent: "SecretParameters",
        polymorphicDiscriminator: SecretParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SecretParameters.type.modelProperties), { keyId: {
                serializedName: "keyId",
                required: true,
                type: {
                    name: "String"
                }
            }, secretSource: {
                serializedName: "secretSource",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, secretVersion: {
                serializedName: "secretVersion",
                type: {
                    name: "String"
                }
            } })
    }
};
const ManagedCertificateParameters = {
    serializedName: "ManagedCertificate",
    type: {
        name: "Composite",
        className: "ManagedCertificateParameters",
        uberParent: "SecretParameters",
        polymorphicDiscriminator: SecretParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SecretParameters.type.modelProperties), { subject: {
                serializedName: "subject",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expirationDate: {
                serializedName: "expirationDate",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const CustomerCertificateParameters = {
    serializedName: "CustomerCertificate",
    type: {
        name: "Composite",
        className: "CustomerCertificateParameters",
        uberParent: "SecretParameters",
        polymorphicDiscriminator: SecretParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SecretParameters.type.modelProperties), { secretSource: {
                serializedName: "secretSource",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, secretVersion: {
                serializedName: "secretVersion",
                type: {
                    name: "String"
                }
            }, useLatestVersion: {
                serializedName: "useLatestVersion",
                type: {
                    name: "Boolean"
                }
            }, subject: {
                serializedName: "subject",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expirationDate: {
                serializedName: "expirationDate",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, certificateAuthority: {
                serializedName: "certificateAuthority",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subjectAlternativeNames: {
                serializedName: "subjectAlternativeNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, thumbprint: {
                serializedName: "thumbprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureFirstPartyManagedCertificateParameters = {
    serializedName: "AzureFirstPartyManagedCertificate",
    type: {
        name: "Composite",
        className: "AzureFirstPartyManagedCertificateParameters",
        uberParent: "SecretParameters",
        polymorphicDiscriminator: SecretParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, SecretParameters.type.modelProperties)
    }
};
const EndpointProperties = {
    type: {
        name: "Composite",
        className: "EndpointProperties",
        modelProperties: Object.assign(Object.assign({}, EndpointPropertiesUpdateParameters.type.modelProperties), { hostName: {
                serializedName: "hostName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, origins: {
                serializedName: "origins",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeepCreatedOrigin"
                        }
                    }
                }
            }, originGroups: {
                serializedName: "originGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeepCreatedOriginGroup"
                        }
                    }
                }
            }, customDomains: {
                serializedName: "customDomains",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeepCreatedCustomDomain"
                        }
                    }
                }
            }, resourceState: {
                serializedName: "resourceState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const OriginProperties = {
    type: {
        name: "Composite",
        className: "OriginProperties",
        modelProperties: Object.assign(Object.assign({}, OriginUpdatePropertiesParameters.type.modelProperties), { resourceState: {
                serializedName: "resourceState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateEndpointStatus: {
                serializedName: "privateEndpointStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const OriginGroupProperties = {
    type: {
        name: "Composite",
        className: "OriginGroupProperties",
        modelProperties: Object.assign(Object.assign({}, OriginGroupUpdatePropertiesParameters.type.modelProperties), { resourceState: {
                serializedName: "resourceState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const CdnManagedHttpsParameters = {
    serializedName: "Cdn",
    type: {
        name: "Composite",
        className: "CdnManagedHttpsParameters",
        uberParent: "CustomDomainHttpsParameters",
        polymorphicDiscriminator: CustomDomainHttpsParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CustomDomainHttpsParameters.type.modelProperties), { certificateSourceParameters: {
                serializedName: "certificateSourceParameters",
                type: {
                    name: "Composite",
                    className: "CdnCertificateSourceParameters"
                }
            } })
    }
};
const UserManagedHttpsParameters = {
    serializedName: "AzureKeyVault",
    type: {
        name: "Composite",
        className: "UserManagedHttpsParameters",
        uberParent: "CustomDomainHttpsParameters",
        polymorphicDiscriminator: CustomDomainHttpsParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CustomDomainHttpsParameters.type.modelProperties), { certificateSourceParameters: {
                serializedName: "certificateSourceParameters",
                type: {
                    name: "Composite",
                    className: "KeyVaultCertificateSourceParameters"
                }
            } })
    }
};
const RateLimitRule = {
    type: {
        name: "Composite",
        className: "RateLimitRule",
        modelProperties: Object.assign(Object.assign({}, CustomRule.type.modelProperties), { rateLimitThreshold: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "rateLimitThreshold",
                required: true,
                type: {
                    name: "Number"
                }
            }, rateLimitDurationInMinutes: {
                constraints: {
                    InclusiveMaximum: 60,
                    InclusiveMinimum: 0
                },
                serializedName: "rateLimitDurationInMinutes",
                required: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const ManagedCertificate = {
    type: {
        name: "Composite",
        className: "ManagedCertificate",
        modelProperties: Object.assign({}, Certificate.type.modelProperties)
    }
};
const CustomerCertificate = {
    type: {
        name: "Composite",
        className: "CustomerCertificate",
        modelProperties: Object.assign(Object.assign({}, Certificate.type.modelProperties), { secretSource: {
                serializedName: "secretSource",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, secretVersion: {
                serializedName: "secretVersion",
                type: {
                    name: "String"
                }
            }, certificateAuthority: {
                serializedName: "certificateAuthority",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, useLatestVersion: {
                serializedName: "useLatestVersion",
                type: {
                    name: "Boolean"
                }
            }, subjectAlternativeNames: {
                serializedName: "subjectAlternativeNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, thumbprint: {
                serializedName: "thumbprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureFirstPartyManagedCertificate = {
    type: {
        name: "Composite",
        className: "AzureFirstPartyManagedCertificate",
        modelProperties: Object.assign({}, Certificate.type.modelProperties)
    }
};
const AFDDomain = {
    type: {
        name: "Composite",
        className: "AFDDomain",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { profileName: {
                serializedName: "properties.profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, tlsSettings: {
                serializedName: "properties.tlsSettings",
                type: {
                    name: "Composite",
                    className: "AFDDomainHttpsParameters"
                }
            }, azureDnsZone: {
                serializedName: "properties.azureDnsZone",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, preValidatedCustomDomainResourceId: {
                serializedName: "properties.preValidatedCustomDomainResourceId",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deploymentStatus: {
                serializedName: "properties.deploymentStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, domainValidationState: {
                serializedName: "properties.domainValidationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String"
                }
            }, validationProperties: {
                serializedName: "properties.validationProperties",
                type: {
                    name: "Composite",
                    className: "DomainValidationProperties"
                }
            } })
    }
};
const AFDOriginGroup = {
    type: {
        name: "Composite",
        className: "AFDOriginGroup",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { profileName: {
                serializedName: "properties.profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, loadBalancingSettings: {
                serializedName: "properties.loadBalancingSettings",
                type: {
                    name: "Composite",
                    className: "LoadBalancingSettingsParameters"
                }
            }, healthProbeSettings: {
                serializedName: "properties.healthProbeSettings",
                type: {
                    name: "Composite",
                    className: "HealthProbeParameters"
                }
            }, trafficRestorationTimeToHealedOrNewEndpointsInMinutes: {
                constraints: {
                    InclusiveMaximum: 50,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.trafficRestorationTimeToHealedOrNewEndpointsInMinutes",
                type: {
                    name: "Number"
                }
            }, sessionAffinityState: {
                serializedName: "properties.sessionAffinityState",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deploymentStatus: {
                serializedName: "properties.deploymentStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AFDOrigin = {
    type: {
        name: "Composite",
        className: "AFDOrigin",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { originGroupName: {
                serializedName: "properties.originGroupName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, azureOrigin: {
                serializedName: "properties.azureOrigin",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String"
                }
            }, httpPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.httpPort",
                type: {
                    name: "Number"
                }
            }, httpsPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.httpsPort",
                type: {
                    name: "Number"
                }
            }, originHostHeader: {
                serializedName: "properties.originHostHeader",
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 5,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, weight: {
                constraints: {
                    InclusiveMaximum: 1000,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.weight",
                type: {
                    name: "Number"
                }
            }, sharedPrivateLinkResource: {
                serializedName: "properties.sharedPrivateLinkResource",
                type: {
                    name: "Composite",
                    className: "SharedPrivateLinkResourceProperties"
                }
            }, enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "String"
                }
            }, enforceCertificateNameCheck: {
                defaultValue: true,
                serializedName: "properties.enforceCertificateNameCheck",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deploymentStatus: {
                serializedName: "properties.deploymentStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Route = {
    type: {
        name: "Composite",
        className: "Route",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { endpointName: {
                serializedName: "properties.endpointName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, customDomains: {
                serializedName: "properties.customDomains",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ActivatedResourceReference"
                        }
                    }
                }
            }, originGroup: {
                serializedName: "properties.originGroup",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, originPath: {
                serializedName: "properties.originPath",
                type: {
                    name: "String"
                }
            }, ruleSets: {
                serializedName: "properties.ruleSets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceReference"
                        }
                    }
                }
            }, supportedProtocols: {
                serializedName: "properties.supportedProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, patternsToMatch: {
                serializedName: "properties.patternsToMatch",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, cacheConfiguration: {
                serializedName: "properties.cacheConfiguration",
                type: {
                    name: "Composite",
                    className: "AfdRouteCacheConfiguration"
                }
            }, forwardingProtocol: {
                serializedName: "properties.forwardingProtocol",
                type: {
                    name: "String"
                }
            }, linkToDefaultDomain: {
                serializedName: "properties.linkToDefaultDomain",
                type: {
                    name: "String"
                }
            }, httpsRedirect: {
                serializedName: "properties.httpsRedirect",
                type: {
                    name: "String"
                }
            }, enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deploymentStatus: {
                serializedName: "properties.deploymentStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const RuleSet = {
    type: {
        name: "Composite",
        className: "RuleSet",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deploymentStatus: {
                serializedName: "properties.deploymentStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, profileName: {
                serializedName: "properties.profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Rule = {
    type: {
        name: "Composite",
        className: "Rule",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { ruleSetName: {
                serializedName: "properties.ruleSetName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, order: {
                serializedName: "properties.order",
                type: {
                    name: "Number"
                }
            }, conditions: {
                serializedName: "properties.conditions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryRuleCondition"
                        }
                    }
                }
            }, actions: {
                serializedName: "properties.actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryRuleActionAutoGenerated"
                        }
                    }
                }
            }, matchProcessingBehavior: {
                serializedName: "properties.matchProcessingBehavior",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deploymentStatus: {
                serializedName: "properties.deploymentStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SecurityPolicy = {
    type: {
        name: "Composite",
        className: "SecurityPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deploymentStatus: {
                serializedName: "properties.deploymentStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, profileName: {
                serializedName: "properties.profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Composite",
                    className: "SecurityPolicyPropertiesParameters"
                }
            } })
    }
};
const Secret = {
    type: {
        name: "Composite",
        className: "Secret",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deploymentStatus: {
                serializedName: "properties.deploymentStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, profileName: {
                serializedName: "properties.profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Composite",
                    className: "SecretParameters"
                }
            } })
    }
};
const Origin = {
    type: {
        name: "Composite",
        className: "Origin",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String"
                }
            }, httpPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.httpPort",
                type: {
                    name: "Number"
                }
            }, httpsPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.httpsPort",
                type: {
                    name: "Number"
                }
            }, originHostHeader: {
                serializedName: "properties.originHostHeader",
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 5,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, weight: {
                constraints: {
                    InclusiveMaximum: 1000,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.weight",
                type: {
                    name: "Number"
                }
            }, enabled: {
                serializedName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }, privateLinkAlias: {
                serializedName: "properties.privateLinkAlias",
                type: {
                    name: "String"
                }
            }, privateLinkResourceId: {
                serializedName: "properties.privateLinkResourceId",
                type: {
                    name: "String"
                }
            }, privateLinkLocation: {
                serializedName: "properties.privateLinkLocation",
                type: {
                    name: "String"
                }
            }, privateLinkApprovalMessage: {
                serializedName: "properties.privateLinkApprovalMessage",
                type: {
                    name: "String"
                }
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateEndpointStatus: {
                serializedName: "properties.privateEndpointStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const OriginGroup = {
    type: {
        name: "Composite",
        className: "OriginGroup",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { healthProbeSettings: {
                serializedName: "properties.healthProbeSettings",
                type: {
                    name: "Composite",
                    className: "HealthProbeParameters"
                }
            }, origins: {
                serializedName: "properties.origins",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceReference"
                        }
                    }
                }
            }, trafficRestorationTimeToHealedOrNewEndpointsInMinutes: {
                constraints: {
                    InclusiveMaximum: 50,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.trafficRestorationTimeToHealedOrNewEndpointsInMinutes",
                type: {
                    name: "Number"
                }
            }, responseBasedOriginErrorDetectionSettings: {
                serializedName: "properties.responseBasedOriginErrorDetectionSettings",
                type: {
                    name: "Composite",
                    className: "ResponseBasedOriginErrorDetectionParameters"
                }
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const CustomDomain = {
    type: {
        name: "Composite",
        className: "CustomDomain",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String"
                }
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, customHttpsProvisioningState: {
                serializedName: "properties.customHttpsProvisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, customHttpsProvisioningSubstate: {
                serializedName: "properties.customHttpsProvisioningSubstate",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, customHttpsParameters: {
                serializedName: "properties.customHttpsParameters",
                type: {
                    name: "Composite",
                    className: "CustomDomainHttpsParameters"
                }
            }, validationData: {
                serializedName: "properties.validationData",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const EdgeNode = {
    type: {
        name: "Composite",
        className: "EdgeNode",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { ipAddressGroups: {
                serializedName: "properties.ipAddressGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAddressGroup"
                        }
                    }
                }
            } })
    }
};
const AFDEndpoint = {
    type: {
        name: "Composite",
        className: "AFDEndpoint",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { profileName: {
                serializedName: "properties.profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deploymentStatus: {
                serializedName: "properties.deploymentStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, hostName: {
                serializedName: "properties.hostName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, autoGeneratedDomainNameLabelScope: {
                serializedName: "properties.autoGeneratedDomainNameLabelScope",
                type: {
                    name: "String"
                }
            } })
    }
};
const Profile = {
    type: {
        name: "Composite",
        className: "Profile",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, frontDoorId: {
                serializedName: "properties.frontDoorId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, originResponseTimeoutSeconds: {
                constraints: {
                    InclusiveMinimum: 16
                },
                serializedName: "properties.originResponseTimeoutSeconds",
                type: {
                    name: "Number"
                }
            } })
    }
};
const Endpoint = {
    type: {
        name: "Composite",
        className: "Endpoint",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { originPath: {
                serializedName: "properties.originPath",
                type: {
                    name: "String"
                }
            }, contentTypesToCompress: {
                serializedName: "properties.contentTypesToCompress",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, originHostHeader: {
                serializedName: "properties.originHostHeader",
                type: {
                    name: "String"
                }
            }, isCompressionEnabled: {
                serializedName: "properties.isCompressionEnabled",
                type: {
                    name: "Boolean"
                }
            }, isHttpAllowed: {
                serializedName: "properties.isHttpAllowed",
                type: {
                    name: "Boolean"
                }
            }, isHttpsAllowed: {
                serializedName: "properties.isHttpsAllowed",
                type: {
                    name: "Boolean"
                }
            }, queryStringCachingBehavior: {
                serializedName: "properties.queryStringCachingBehavior",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "IgnoreQueryString",
                        "BypassCaching",
                        "UseQueryString",
                        "NotSet"
                    ]
                }
            }, optimizationType: {
                serializedName: "properties.optimizationType",
                type: {
                    name: "String"
                }
            }, probePath: {
                serializedName: "properties.probePath",
                type: {
                    name: "String"
                }
            }, geoFilters: {
                serializedName: "properties.geoFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GeoFilter"
                        }
                    }
                }
            }, defaultOriginGroup: {
                serializedName: "properties.defaultOriginGroup",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, urlSigningKeys: {
                serializedName: "properties.urlSigningKeys",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UrlSigningKey"
                        }
                    }
                }
            }, deliveryPolicy: {
                serializedName: "properties.deliveryPolicy",
                type: {
                    name: "Composite",
                    className: "EndpointPropertiesUpdateParametersDeliveryPolicy"
                }
            }, webApplicationFirewallPolicyLink: {
                serializedName: "properties.webApplicationFirewallPolicyLink",
                type: {
                    name: "Composite",
                    className: "EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink"
                }
            }, hostName: {
                serializedName: "properties.hostName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, origins: {
                serializedName: "properties.origins",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeepCreatedOrigin"
                        }
                    }
                }
            }, originGroups: {
                serializedName: "properties.originGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeepCreatedOriginGroup"
                        }
                    }
                }
            }, customDomains: {
                serializedName: "properties.customDomains",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeepCreatedCustomDomain"
                        }
                    }
                }
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const CdnWebApplicationFirewallPolicy = {
    type: {
        name: "Composite",
        className: "CdnWebApplicationFirewallPolicy",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, policySettings: {
                serializedName: "properties.policySettings",
                type: {
                    name: "Composite",
                    className: "PolicySettings"
                }
            }, rateLimitRules: {
                serializedName: "properties.rateLimitRules",
                type: {
                    name: "Composite",
                    className: "RateLimitRuleList"
                }
            }, customRules: {
                serializedName: "properties.customRules",
                type: {
                    name: "Composite",
                    className: "CustomRuleList"
                }
            }, managedRules: {
                serializedName: "properties.managedRules",
                type: {
                    name: "Composite",
                    className: "ManagedRuleSetList"
                }
            }, endpointLinks: {
                serializedName: "properties.endpointLinks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CdnEndpoint"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
let discriminators = {
    DeliveryRuleCondition: DeliveryRuleCondition,
    DeliveryRuleActionAutoGenerated: DeliveryRuleActionAutoGenerated,
    SecurityPolicyPropertiesParameters: SecurityPolicyPropertiesParameters,
    SecretParameters: SecretParameters,
    CustomDomainHttpsParameters: CustomDomainHttpsParameters,
    "DeliveryRuleCondition.RemoteAddress": DeliveryRuleRemoteAddressCondition,
    "DeliveryRuleCondition.RequestMethod": DeliveryRuleRequestMethodCondition,
    "DeliveryRuleCondition.QueryString": DeliveryRuleQueryStringCondition,
    "DeliveryRuleCondition.PostArgs": DeliveryRulePostArgsCondition,
    "DeliveryRuleCondition.RequestUri": DeliveryRuleRequestUriCondition,
    "DeliveryRuleCondition.RequestHeader": DeliveryRuleRequestHeaderCondition,
    "DeliveryRuleCondition.RequestBody": DeliveryRuleRequestBodyCondition,
    "DeliveryRuleCondition.RequestScheme": DeliveryRuleRequestSchemeCondition,
    "DeliveryRuleCondition.UrlPath": DeliveryRuleUrlPathCondition,
    "DeliveryRuleCondition.UrlFileExtension": DeliveryRuleUrlFileExtensionCondition,
    "DeliveryRuleCondition.UrlFileName": DeliveryRuleUrlFileNameCondition,
    "DeliveryRuleCondition.HttpVersion": DeliveryRuleHttpVersionCondition,
    "DeliveryRuleCondition.Cookies": DeliveryRuleCookiesCondition,
    "DeliveryRuleCondition.IsDevice": DeliveryRuleIsDeviceCondition,
    "DeliveryRuleCondition.SocketAddr": DeliveryRuleSocketAddrCondition,
    "DeliveryRuleCondition.ClientPort": DeliveryRuleClientPortCondition,
    "DeliveryRuleCondition.ServerPort": DeliveryRuleServerPortCondition,
    "DeliveryRuleCondition.HostName": DeliveryRuleHostNameCondition,
    "DeliveryRuleCondition.SslProtocol": DeliveryRuleSslProtocolCondition,
    "DeliveryRuleActionAutoGenerated.UrlRedirect": UrlRedirectAction,
    "DeliveryRuleActionAutoGenerated.UrlSigning": UrlSigningAction,
    "DeliveryRuleActionAutoGenerated.OriginGroupOverride": OriginGroupOverrideAction,
    "DeliveryRuleActionAutoGenerated.UrlRewrite": UrlRewriteAction,
    "DeliveryRuleActionAutoGenerated.ModifyRequestHeader": DeliveryRuleRequestHeaderAction,
    "DeliveryRuleActionAutoGenerated.ModifyResponseHeader": DeliveryRuleResponseHeaderAction,
    "DeliveryRuleActionAutoGenerated.CacheExpiration": DeliveryRuleCacheExpirationAction,
    "DeliveryRuleActionAutoGenerated.CacheKeyQueryString": DeliveryRuleCacheKeyQueryStringAction,
    "DeliveryRuleActionAutoGenerated.RouteConfigurationOverride": DeliveryRuleRouteConfigurationOverrideAction,
    "SecurityPolicyPropertiesParameters.WebApplicationFirewall": SecurityPolicyWebApplicationFirewallParameters,
    "SecretParameters.UrlSigningKey": UrlSigningKeyParameters,
    "SecretParameters.ManagedCertificate": ManagedCertificateParameters,
    "SecretParameters.CustomerCertificate": CustomerCertificateParameters,
    "SecretParameters.AzureFirstPartyManagedCertificate": AzureFirstPartyManagedCertificateParameters,
    "CustomDomainHttpsParameters.Cdn": CdnManagedHttpsParameters,
    "CustomDomainHttpsParameters.AzureKeyVault": UserManagedHttpsParameters
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CheckEndpointNameAvailabilityInput: CheckEndpointNameAvailabilityInput,
    CheckEndpointNameAvailabilityOutput: CheckEndpointNameAvailabilityOutput,
    AfdErrorResponse: AfdErrorResponse,
    ErrorDetail: ErrorDetail,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    UsagesListResult: UsagesListResult,
    Usage: Usage,
    UsageName: UsageName,
    CheckHostNameAvailabilityInput: CheckHostNameAvailabilityInput,
    CheckNameAvailabilityOutput: CheckNameAvailabilityOutput,
    AFDDomainListResult: AFDDomainListResult,
    DomainValidationProperties: DomainValidationProperties,
    AFDDomainUpdatePropertiesParameters: AFDDomainUpdatePropertiesParameters,
    AFDDomainHttpsParameters: AFDDomainHttpsParameters,
    ResourceReference: ResourceReference,
    AFDStateProperties: AFDStateProperties,
    Resource: Resource,
    SystemData: SystemData,
    AFDDomainUpdateParameters: AFDDomainUpdateParameters,
    AFDEndpointListResult: AFDEndpointListResult,
    AFDEndpointPropertiesUpdateParameters: AFDEndpointPropertiesUpdateParameters,
    AFDEndpointUpdateParameters: AFDEndpointUpdateParameters,
    AfdPurgeParameters: AfdPurgeParameters,
    ValidateCustomDomainInput: ValidateCustomDomainInput,
    ValidateCustomDomainOutput: ValidateCustomDomainOutput,
    AFDOriginGroupListResult: AFDOriginGroupListResult,
    AFDOriginGroupUpdatePropertiesParameters: AFDOriginGroupUpdatePropertiesParameters,
    LoadBalancingSettingsParameters: LoadBalancingSettingsParameters,
    HealthProbeParameters: HealthProbeParameters,
    AFDOriginGroupUpdateParameters: AFDOriginGroupUpdateParameters,
    AFDOriginListResult: AFDOriginListResult,
    AFDOriginUpdatePropertiesParameters: AFDOriginUpdatePropertiesParameters,
    SharedPrivateLinkResourceProperties: SharedPrivateLinkResourceProperties,
    AFDOriginUpdateParameters: AFDOriginUpdateParameters,
    RouteListResult: RouteListResult,
    RouteUpdatePropertiesParameters: RouteUpdatePropertiesParameters,
    ActivatedResourceReference: ActivatedResourceReference,
    AfdRouteCacheConfiguration: AfdRouteCacheConfiguration,
    CompressionSettings: CompressionSettings,
    RouteUpdateParameters: RouteUpdateParameters,
    RuleSetListResult: RuleSetListResult,
    RuleListResult: RuleListResult,
    RuleUpdatePropertiesParameters: RuleUpdatePropertiesParameters,
    DeliveryRuleCondition: DeliveryRuleCondition,
    DeliveryRuleActionAutoGenerated: DeliveryRuleActionAutoGenerated,
    RuleUpdateParameters: RuleUpdateParameters,
    SecurityPolicyListResult: SecurityPolicyListResult,
    SecurityPolicyPropertiesParameters: SecurityPolicyPropertiesParameters,
    SecurityPolicyUpdateParameters: SecurityPolicyUpdateParameters,
    SecretListResult: SecretListResult,
    SecretParameters: SecretParameters,
    ValidateSecretInput: ValidateSecretInput,
    ValidateSecretOutput: ValidateSecretOutput,
    MetricsResponse: MetricsResponse,
    MetricsResponseSeriesItem: MetricsResponseSeriesItem,
    MetricsResponseSeriesPropertiesItemsItem: MetricsResponseSeriesPropertiesItemsItem,
    Components1Gs0LlpSchemasMetricsresponsePropertiesSeriesItemsPropertiesDataItems: Components1Gs0LlpSchemasMetricsresponsePropertiesSeriesItemsPropertiesDataItems,
    RankingsResponse: RankingsResponse,
    RankingsResponseTablesItem: RankingsResponseTablesItem,
    RankingsResponseTablesPropertiesItemsItem: RankingsResponseTablesPropertiesItemsItem,
    RankingsResponseTablesPropertiesItemsMetricsItem: RankingsResponseTablesPropertiesItemsMetricsItem,
    ContinentsResponse: ContinentsResponse,
    ContinentsResponseContinentsItem: ContinentsResponseContinentsItem,
    ContinentsResponseCountryOrRegionsItem: ContinentsResponseCountryOrRegionsItem,
    ResourcesResponse: ResourcesResponse,
    ResourcesResponseEndpointsItem: ResourcesResponseEndpointsItem,
    ResourcesResponseEndpointsPropertiesItemsItem: ResourcesResponseEndpointsPropertiesItemsItem,
    ResourcesResponseCustomDomainsItem: ResourcesResponseCustomDomainsItem,
    WafMetricsResponse: WafMetricsResponse,
    WafMetricsResponseSeriesItem: WafMetricsResponseSeriesItem,
    WafMetricsResponseSeriesPropertiesItemsItem: WafMetricsResponseSeriesPropertiesItemsItem,
    Components18OrqelSchemasWafmetricsresponsePropertiesSeriesItemsPropertiesDataItems: Components18OrqelSchemasWafmetricsresponsePropertiesSeriesItemsPropertiesDataItems,
    WafRankingsResponse: WafRankingsResponse,
    WafRankingsResponseDataItem: WafRankingsResponseDataItem,
    ComponentsKpo1PjSchemasWafrankingsresponsePropertiesDataItemsPropertiesMetricsItems: ComponentsKpo1PjSchemasWafrankingsresponsePropertiesDataItemsPropertiesMetricsItems,
    ProfileListResult: ProfileListResult,
    Sku: Sku,
    ErrorResponse: ErrorResponse,
    ProfileUpdateParameters: ProfileUpdateParameters,
    SsoUri: SsoUri,
    SupportedOptimizationTypesListResult: SupportedOptimizationTypesListResult,
    ResourceUsageListResult: ResourceUsageListResult,
    ResourceUsage: ResourceUsage,
    EndpointListResult: EndpointListResult,
    DeepCreatedOrigin: DeepCreatedOrigin,
    DeepCreatedOriginGroup: DeepCreatedOriginGroup,
    ResponseBasedOriginErrorDetectionParameters: ResponseBasedOriginErrorDetectionParameters,
    HttpErrorRangeParameters: HttpErrorRangeParameters,
    DeepCreatedCustomDomain: DeepCreatedCustomDomain,
    EndpointPropertiesUpdateParameters: EndpointPropertiesUpdateParameters,
    GeoFilter: GeoFilter,
    UrlSigningKey: UrlSigningKey,
    KeyVaultSigningKeyParameters: KeyVaultSigningKeyParameters,
    EndpointPropertiesUpdateParametersDeliveryPolicy: EndpointPropertiesUpdateParametersDeliveryPolicy,
    DeliveryRule: DeliveryRule,
    EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink: EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink,
    EndpointUpdateParameters: EndpointUpdateParameters,
    PurgeParameters: PurgeParameters,
    LoadParameters: LoadParameters,
    OriginListResult: OriginListResult,
    OriginUpdatePropertiesParameters: OriginUpdatePropertiesParameters,
    OriginUpdateParameters: OriginUpdateParameters,
    OriginGroupListResult: OriginGroupListResult,
    OriginGroupUpdatePropertiesParameters: OriginGroupUpdatePropertiesParameters,
    OriginGroupUpdateParameters: OriginGroupUpdateParameters,
    CustomDomainListResult: CustomDomainListResult,
    CustomDomainHttpsParameters: CustomDomainHttpsParameters,
    CustomDomainParameters: CustomDomainParameters,
    CheckNameAvailabilityInput: CheckNameAvailabilityInput,
    ValidateProbeInput: ValidateProbeInput,
    ValidateProbeOutput: ValidateProbeOutput,
    OperationsListResult: OperationsListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    ServiceSpecification: ServiceSpecification,
    LogSpecification: LogSpecification,
    MetricSpecification: MetricSpecification,
    MetricAvailability: MetricAvailability,
    DimensionProperties: DimensionProperties,
    EdgenodeResult: EdgenodeResult,
    IpAddressGroup: IpAddressGroup,
    CidrIpAddress: CidrIpAddress,
    CdnWebApplicationFirewallPolicyList: CdnWebApplicationFirewallPolicyList,
    PolicySettings: PolicySettings,
    RateLimitRuleList: RateLimitRuleList,
    CustomRule: CustomRule,
    MatchCondition: MatchCondition,
    CustomRuleList: CustomRuleList,
    ManagedRuleSetList: ManagedRuleSetList,
    ManagedRuleSet: ManagedRuleSet,
    ManagedRuleGroupOverride: ManagedRuleGroupOverride,
    ManagedRuleOverride: ManagedRuleOverride,
    CdnEndpoint: CdnEndpoint,
    CdnWebApplicationFirewallPolicyPatchParameters: CdnWebApplicationFirewallPolicyPatchParameters,
    ManagedRuleSetDefinitionList: ManagedRuleSetDefinitionList,
    ManagedRuleGroupDefinition: ManagedRuleGroupDefinition,
    ManagedRuleDefinition: ManagedRuleDefinition,
    Certificate: Certificate,
    SecurityPolicyWebApplicationFirewallAssociation: SecurityPolicyWebApplicationFirewallAssociation,
    ValidationToken: ValidationToken,
    RemoteAddressMatchConditionParameters: RemoteAddressMatchConditionParameters,
    RequestMethodMatchConditionParameters: RequestMethodMatchConditionParameters,
    QueryStringMatchConditionParameters: QueryStringMatchConditionParameters,
    PostArgsMatchConditionParameters: PostArgsMatchConditionParameters,
    RequestUriMatchConditionParameters: RequestUriMatchConditionParameters,
    RequestHeaderMatchConditionParameters: RequestHeaderMatchConditionParameters,
    RequestBodyMatchConditionParameters: RequestBodyMatchConditionParameters,
    RequestSchemeMatchConditionParameters: RequestSchemeMatchConditionParameters,
    UrlPathMatchConditionParameters: UrlPathMatchConditionParameters,
    UrlFileExtensionMatchConditionParameters: UrlFileExtensionMatchConditionParameters,
    UrlFileNameMatchConditionParameters: UrlFileNameMatchConditionParameters,
    HttpVersionMatchConditionParameters: HttpVersionMatchConditionParameters,
    CookiesMatchConditionParameters: CookiesMatchConditionParameters,
    IsDeviceMatchConditionParameters: IsDeviceMatchConditionParameters,
    SocketAddrMatchConditionParameters: SocketAddrMatchConditionParameters,
    ClientPortMatchConditionParameters: ClientPortMatchConditionParameters,
    ServerPortMatchConditionParameters: ServerPortMatchConditionParameters,
    HostNameMatchConditionParameters: HostNameMatchConditionParameters,
    SslProtocolMatchConditionParameters: SslProtocolMatchConditionParameters,
    UrlRedirectActionParameters: UrlRedirectActionParameters,
    UrlSigningActionParameters: UrlSigningActionParameters,
    UrlSigningParamIdentifier: UrlSigningParamIdentifier,
    OriginGroupOverrideActionParameters: OriginGroupOverrideActionParameters,
    UrlRewriteActionParameters: UrlRewriteActionParameters,
    HeaderActionParameters: HeaderActionParameters,
    CacheExpirationActionParameters: CacheExpirationActionParameters,
    CacheKeyQueryStringActionParameters: CacheKeyQueryStringActionParameters,
    RouteConfigurationOverrideActionParameters: RouteConfigurationOverrideActionParameters,
    OriginGroupOverride: OriginGroupOverride,
    CacheConfiguration: CacheConfiguration,
    CdnCertificateSourceParameters: CdnCertificateSourceParameters,
    KeyVaultCertificateSourceParameters: KeyVaultCertificateSourceParameters,
    AFDDomainProperties: AFDDomainProperties,
    AFDEndpointProperties: AFDEndpointProperties,
    AFDOriginGroupProperties: AFDOriginGroupProperties,
    AFDOriginProperties: AFDOriginProperties,
    RouteProperties: RouteProperties,
    RuleSetProperties: RuleSetProperties,
    RuleProperties: RuleProperties,
    SecurityPolicyProperties: SecurityPolicyProperties,
    SecretProperties: SecretProperties,
    ProxyResource: ProxyResource,
    TrackedResource: TrackedResource,
    ManagedRuleSetDefinition: ManagedRuleSetDefinition,
    DeliveryRuleRemoteAddressCondition: DeliveryRuleRemoteAddressCondition,
    DeliveryRuleRequestMethodCondition: DeliveryRuleRequestMethodCondition,
    DeliveryRuleQueryStringCondition: DeliveryRuleQueryStringCondition,
    DeliveryRulePostArgsCondition: DeliveryRulePostArgsCondition,
    DeliveryRuleRequestUriCondition: DeliveryRuleRequestUriCondition,
    DeliveryRuleRequestHeaderCondition: DeliveryRuleRequestHeaderCondition,
    DeliveryRuleRequestBodyCondition: DeliveryRuleRequestBodyCondition,
    DeliveryRuleRequestSchemeCondition: DeliveryRuleRequestSchemeCondition,
    DeliveryRuleUrlPathCondition: DeliveryRuleUrlPathCondition,
    DeliveryRuleUrlFileExtensionCondition: DeliveryRuleUrlFileExtensionCondition,
    DeliveryRuleUrlFileNameCondition: DeliveryRuleUrlFileNameCondition,
    DeliveryRuleHttpVersionCondition: DeliveryRuleHttpVersionCondition,
    DeliveryRuleCookiesCondition: DeliveryRuleCookiesCondition,
    DeliveryRuleIsDeviceCondition: DeliveryRuleIsDeviceCondition,
    DeliveryRuleSocketAddrCondition: DeliveryRuleSocketAddrCondition,
    DeliveryRuleClientPortCondition: DeliveryRuleClientPortCondition,
    DeliveryRuleServerPortCondition: DeliveryRuleServerPortCondition,
    DeliveryRuleHostNameCondition: DeliveryRuleHostNameCondition,
    DeliveryRuleSslProtocolCondition: DeliveryRuleSslProtocolCondition,
    UrlRedirectAction: UrlRedirectAction,
    UrlSigningAction: UrlSigningAction,
    OriginGroupOverrideAction: OriginGroupOverrideAction,
    UrlRewriteAction: UrlRewriteAction,
    DeliveryRuleRequestHeaderAction: DeliveryRuleRequestHeaderAction,
    DeliveryRuleResponseHeaderAction: DeliveryRuleResponseHeaderAction,
    DeliveryRuleCacheExpirationAction: DeliveryRuleCacheExpirationAction,
    DeliveryRuleCacheKeyQueryStringAction: DeliveryRuleCacheKeyQueryStringAction,
    DeliveryRuleRouteConfigurationOverrideAction: DeliveryRuleRouteConfigurationOverrideAction,
    SecurityPolicyWebApplicationFirewallParameters: SecurityPolicyWebApplicationFirewallParameters,
    UrlSigningKeyParameters: UrlSigningKeyParameters,
    ManagedCertificateParameters: ManagedCertificateParameters,
    CustomerCertificateParameters: CustomerCertificateParameters,
    AzureFirstPartyManagedCertificateParameters: AzureFirstPartyManagedCertificateParameters,
    EndpointProperties: EndpointProperties,
    OriginProperties: OriginProperties,
    OriginGroupProperties: OriginGroupProperties,
    CdnManagedHttpsParameters: CdnManagedHttpsParameters,
    UserManagedHttpsParameters: UserManagedHttpsParameters,
    RateLimitRule: RateLimitRule,
    ManagedCertificate: ManagedCertificate,
    CustomerCertificate: CustomerCertificate,
    AzureFirstPartyManagedCertificate: AzureFirstPartyManagedCertificate,
    AFDDomain: AFDDomain,
    AFDOriginGroup: AFDOriginGroup,
    AFDOrigin: AFDOrigin,
    Route: Route,
    RuleSet: RuleSet,
    Rule: Rule,
    SecurityPolicy: SecurityPolicy,
    Secret: Secret,
    Origin: Origin,
    OriginGroup: OriginGroup,
    CustomDomain: CustomDomain,
    EdgeNode: EdgeNode,
    AFDEndpoint: AFDEndpoint,
    Profile: Profile,
    Endpoint: Endpoint,
    CdnWebApplicationFirewallPolicy: CdnWebApplicationFirewallPolicy,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const checkEndpointNameAvailabilityInput = {
    parameterPath: "checkEndpointNameAvailabilityInput",
    mapper: CheckEndpointNameAvailabilityInput
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._\\(\\)]+$"),
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-06-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const checkNameAvailabilityInput = {
    parameterPath: "checkNameAvailabilityInput",
    mapper: CheckNameAvailabilityInput
};
const validateProbeInput = {
    parameterPath: "validateProbeInput",
    mapper: ValidateProbeInput
};
const profileName = {
    parameterPath: "profileName",
    mapper: {
        serializedName: "profileName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const checkHostNameAvailabilityInput = {
    parameterPath: "checkHostNameAvailabilityInput",
    mapper: CheckHostNameAvailabilityInput
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const customDomainName = {
    parameterPath: "customDomainName",
    mapper: {
        serializedName: "customDomainName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const customDomain = {
    parameterPath: "customDomain",
    mapper: AFDDomain
};
const customDomainUpdateProperties = {
    parameterPath: "customDomainUpdateProperties",
    mapper: AFDDomainUpdateParameters
};
const endpointName = {
    parameterPath: "endpointName",
    mapper: {
        serializedName: "endpointName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: AFDEndpoint
};
const endpointUpdateProperties = {
    parameterPath: "endpointUpdateProperties",
    mapper: AFDEndpointUpdateParameters
};
const contents = {
    parameterPath: "contents",
    mapper: AfdPurgeParameters
};
const customDomainProperties = {
    parameterPath: "customDomainProperties",
    mapper: ValidateCustomDomainInput
};
const originGroupName = {
    parameterPath: "originGroupName",
    mapper: {
        serializedName: "originGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const originGroup = {
    parameterPath: "originGroup",
    mapper: AFDOriginGroup
};
const originGroupUpdateProperties = {
    parameterPath: "originGroupUpdateProperties",
    mapper: AFDOriginGroupUpdateParameters
};
const originName = {
    parameterPath: "originName",
    mapper: {
        serializedName: "originName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const origin = {
    parameterPath: "origin",
    mapper: AFDOrigin
};
const originUpdateProperties = {
    parameterPath: "originUpdateProperties",
    mapper: AFDOriginUpdateParameters
};
const routeName = {
    parameterPath: "routeName",
    mapper: {
        serializedName: "routeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const route = {
    parameterPath: "route",
    mapper: Route
};
const routeUpdateProperties = {
    parameterPath: "routeUpdateProperties",
    mapper: RouteUpdateParameters
};
const ruleSetName = {
    parameterPath: "ruleSetName",
    mapper: {
        serializedName: "ruleSetName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const ruleName = {
    parameterPath: "ruleName",
    mapper: {
        serializedName: "ruleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const rule = {
    parameterPath: "rule",
    mapper: Rule
};
const ruleUpdateProperties = {
    parameterPath: "ruleUpdateProperties",
    mapper: RuleUpdateParameters
};
const securityPolicyName = {
    parameterPath: "securityPolicyName",
    mapper: {
        serializedName: "securityPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const securityPolicy = {
    parameterPath: "securityPolicy",
    mapper: SecurityPolicy
};
const securityPolicyUpdateProperties = {
    parameterPath: "securityPolicyUpdateProperties",
    mapper: SecurityPolicyUpdateParameters
};
const secretName = {
    parameterPath: "secretName",
    mapper: {
        serializedName: "secretName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const secret = {
    parameterPath: "secret",
    mapper: Secret
};
const validateSecretInput = {
    parameterPath: "validateSecretInput",
    mapper: ValidateSecretInput
};
const metrics = {
    parameterPath: "metrics",
    mapper: {
        serializedName: "metrics",
        required: true,
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const dateTimeBegin = {
    parameterPath: "dateTimeBegin",
    mapper: {
        serializedName: "dateTimeBegin",
        required: true,
        type: {
            name: "DateTime"
        }
    }
};
const dateTimeEnd = {
    parameterPath: "dateTimeEnd",
    mapper: {
        serializedName: "dateTimeEnd",
        required: true,
        type: {
            name: "DateTime"
        }
    }
};
const granularity = {
    parameterPath: "granularity",
    mapper: {
        serializedName: "granularity",
        required: true,
        type: {
            name: "String"
        }
    }
};
const groupBy = {
    parameterPath: ["options", "groupBy"],
    mapper: {
        serializedName: "groupBy",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const continents = {
    parameterPath: ["options", "continents"],
    mapper: {
        serializedName: "continents",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const countryOrRegions = {
    parameterPath: ["options", "countryOrRegions"],
    mapper: {
        serializedName: "countryOrRegions",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const customDomains = {
    parameterPath: "customDomains",
    mapper: {
        serializedName: "customDomains",
        required: true,
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const protocols = {
    parameterPath: "protocols",
    mapper: {
        serializedName: "protocols",
        required: true,
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const rankings = {
    parameterPath: "rankings",
    mapper: {
        serializedName: "rankings",
        required: true,
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const metrics1 = {
    parameterPath: "metrics",
    mapper: {
        serializedName: "metrics",
        required: true,
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const maxRanking = {
    parameterPath: "maxRanking",
    mapper: {
        serializedName: "maxRanking",
        required: true,
        type: {
            name: "Number"
        }
    }
};
const customDomains1 = {
    parameterPath: ["options", "customDomains"],
    mapper: {
        serializedName: "customDomains",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const metrics2 = {
    parameterPath: "metrics",
    mapper: {
        serializedName: "metrics",
        required: true,
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const granularity1 = {
    parameterPath: "granularity",
    mapper: {
        serializedName: "granularity",
        required: true,
        type: {
            name: "String"
        }
    }
};
const actions = {
    parameterPath: ["options", "actions"],
    mapper: {
        serializedName: "actions",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const groupBy1 = {
    parameterPath: ["options", "groupBy"],
    mapper: {
        serializedName: "groupBy",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const ruleTypes = {
    parameterPath: ["options", "ruleTypes"],
    mapper: {
        serializedName: "ruleTypes",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const rankings1 = {
    parameterPath: "rankings",
    mapper: {
        serializedName: "rankings",
        required: true,
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const profile = {
    parameterPath: "profile",
    mapper: Profile
};
const profileUpdateParameters = {
    parameterPath: "profileUpdateParameters",
    mapper: ProfileUpdateParameters
};
const endpoint1 = {
    parameterPath: "endpoint",
    mapper: Endpoint
};
const endpointUpdateProperties1 = {
    parameterPath: "endpointUpdateProperties",
    mapper: EndpointUpdateParameters
};
const contentFilePaths = {
    parameterPath: "contentFilePaths",
    mapper: PurgeParameters
};
const contentFilePaths1 = {
    parameterPath: "contentFilePaths",
    mapper: LoadParameters
};
const origin1 = {
    parameterPath: "origin",
    mapper: Origin
};
const originUpdateProperties1 = {
    parameterPath: "originUpdateProperties",
    mapper: OriginUpdateParameters
};
const originGroup1 = {
    parameterPath: "originGroup",
    mapper: OriginGroup
};
const originGroupUpdateProperties1 = {
    parameterPath: "originGroupUpdateProperties",
    mapper: OriginGroupUpdateParameters
};
const customDomainProperties1 = {
    parameterPath: "customDomainProperties",
    mapper: CustomDomainParameters
};
const customDomainHttpsParameters = {
    parameterPath: ["options", "customDomainHttpsParameters"],
    mapper: CustomDomainHttpsParameters
};
const resourceGroupName1 = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9_\\-\\(\\)\\.]*[^\\.]$"),
            MaxLength: 80,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const policyName = {
    parameterPath: "policyName",
    mapper: {
        constraints: {
            MaxLength: 128
        },
        serializedName: "policyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const cdnWebApplicationFirewallPolicy = {
    parameterPath: "cdnWebApplicationFirewallPolicy",
    mapper: CdnWebApplicationFirewallPolicy
};
const cdnWebApplicationFirewallPolicyPatchParameters = {
    parameterPath: "cdnWebApplicationFirewallPolicyPatchParameters",
    mapper: CdnWebApplicationFirewallPolicyPatchParameters
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AfdProfiles operations. */
class AfdProfilesImpl {
    /**
     * Initialize a new instance of the class AfdProfiles class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Checks the quota and actual usage of AzureFrontDoor endpoints under the given CDN profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param options The options parameters.
     */
    listResourceUsage(resourceGroupName, profileName, options) {
        const iter = this.listResourceUsagePagingAll(resourceGroupName, profileName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listResourceUsagePagingPage(resourceGroupName, profileName, options, settings);
            }
        };
    }
    listResourceUsagePagingPage(resourceGroupName, profileName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listResourceUsagePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listResourceUsage(resourceGroupName, profileName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listResourceUsageNext(resourceGroupName, profileName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listResourceUsagePagingAll(resourceGroupName, profileName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listResourceUsagePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listResourceUsagePagingPage(resourceGroupName, profileName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Checks the quota and actual usage of AzureFrontDoor endpoints under the given CDN profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param options The options parameters.
     */
    _listResourceUsage(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, listResourceUsageOperationSpec$5);
    }
    /**
     * Check the name availability of a host name.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param checkHostNameAvailabilityInput Custom domain to be validated.
     * @param options The options parameters.
     */
    checkHostNameAvailability(resourceGroupName, profileName, checkHostNameAvailabilityInput, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            profileName,
            checkHostNameAvailabilityInput,
            options
        }, checkHostNameAvailabilityOperationSpec);
    }
    /**
     * ListResourceUsageNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListResourceUsage method.
     * @param options The options parameters.
     */
    _listResourceUsageNext(resourceGroupName, profileName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, nextLink, options }, listResourceUsageNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$m = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listResourceUsageOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/usages",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: UsagesListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const checkHostNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/checkHostNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityOutput
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: checkHostNameAvailabilityInput,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$m
};
const listResourceUsageNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsagesListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AfdCustomDomains operations. */
class AfdCustomDomainsImpl {
    /**
     * Initialize a new instance of the class AfdCustomDomains class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists existing AzureFrontDoor domains.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile or CDN
     *                    profile which is unique within the resource group.
     * @param options The options parameters.
     */
    listByProfile(resourceGroupName, profileName, options) {
        const iter = this.listByProfilePagingAll(resourceGroupName, profileName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByProfilePagingPage(resourceGroupName, profileName, options, settings);
            }
        };
    }
    listByProfilePagingPage(resourceGroupName, profileName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByProfile(resourceGroupName, profileName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByProfileNext(resourceGroupName, profileName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByProfilePagingAll(resourceGroupName, profileName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByProfilePagingPage(resourceGroupName, profileName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists existing AzureFrontDoor domains.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile or CDN
     *                    profile which is unique within the resource group.
     * @param options The options parameters.
     */
    _listByProfile(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, listByProfileOperationSpec$6);
    }
    /**
     * Gets an existing AzureFrontDoor domain with the specified domain name under the specified
     * subscription, resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param customDomainName Name of the domain under the profile which is unique globally.
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, customDomainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, customDomainName, options }, getOperationSpec$e);
    }
    /**
     * Creates a new domain within the specified profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param customDomainName Name of the domain under the profile which is unique globally
     * @param customDomain Domain properties
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, profileName, customDomainName, customDomain, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                customDomainName,
                customDomain,
                options
            }, createOperationSpec$d);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new domain within the specified profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param customDomainName Name of the domain under the profile which is unique globally
     * @param customDomain Domain properties
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, profileName, customDomainName, customDomain, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, profileName, customDomainName, customDomain, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing domain within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param customDomainName Name of the domain under the profile which is unique globally
     * @param customDomainUpdateProperties Domain properties
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, profileName, customDomainName, customDomainUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                customDomainName,
                customDomainUpdateProperties,
                options
            }, updateOperationSpec$a);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an existing domain within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param customDomainName Name of the domain under the profile which is unique globally
     * @param customDomainUpdateProperties Domain properties
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, profileName, customDomainName, customDomainUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, profileName, customDomainName, customDomainUpdateProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing AzureFrontDoor domain with the specified domain name under the specified
     * subscription, resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param customDomainName Name of the domain under the profile which is unique globally.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, customDomainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, customDomainName, options }, deleteOperationSpec$e);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing AzureFrontDoor domain with the specified domain name under the specified
     * subscription, resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param customDomainName Name of the domain under the profile which is unique globally.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, customDomainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, customDomainName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the domain validation token.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param customDomainName Name of the domain under the profile which is unique globally.
     * @param options The options parameters.
     */
    beginRefreshValidationToken(resourceGroupName, profileName, customDomainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, customDomainName, options }, refreshValidationTokenOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the domain validation token.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param customDomainName Name of the domain under the profile which is unique globally.
     * @param options The options parameters.
     */
    beginRefreshValidationTokenAndWait(resourceGroupName, profileName, customDomainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRefreshValidationToken(resourceGroupName, profileName, customDomainName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByProfileNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile or CDN
     *                    profile which is unique within the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByProfile method.
     * @param options The options parameters.
     */
    _listByProfileNext(resourceGroupName, profileName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, nextLink, options }, listByProfileNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$l = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByProfileOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/customDomains",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AFDDomainListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/customDomains/{customDomainName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AFDDomain
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        customDomainName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const createOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/customDomains/{customDomainName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AFDDomain
        },
        201: {
            bodyMapper: AFDDomain
        },
        202: {
            bodyMapper: AFDDomain
        },
        204: {
            bodyMapper: AFDDomain
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: customDomain,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        customDomainName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$l
};
const updateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/customDomains/{customDomainName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AFDDomain
        },
        201: {
            bodyMapper: AFDDomain
        },
        202: {
            bodyMapper: AFDDomain
        },
        204: {
            bodyMapper: AFDDomain
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: customDomainUpdateProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        customDomainName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$l
};
const deleteOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/customDomains/{customDomainName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        customDomainName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const refreshValidationTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/customDomains/{customDomainName}/refreshValidationToken",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        customDomainName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listByProfileNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AFDDomainListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AfdEndpoints operations. */
class AfdEndpointsImpl {
    /**
     * Initialize a new instance of the class AfdEndpoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists existing AzureFrontDoor endpoints.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param options The options parameters.
     */
    listByProfile(resourceGroupName, profileName, options) {
        const iter = this.listByProfilePagingAll(resourceGroupName, profileName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByProfilePagingPage(resourceGroupName, profileName, options, settings);
            }
        };
    }
    listByProfilePagingPage(resourceGroupName, profileName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByProfile(resourceGroupName, profileName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByProfileNext(resourceGroupName, profileName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByProfilePagingAll(resourceGroupName, profileName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByProfilePagingPage(resourceGroupName, profileName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Checks the quota and actual usage of the given AzureFrontDoor endpoint under the given CDN profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    listResourceUsage(resourceGroupName, profileName, endpointName, options) {
        const iter = this.listResourceUsagePagingAll(resourceGroupName, profileName, endpointName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listResourceUsagePagingPage(resourceGroupName, profileName, endpointName, options, settings);
            }
        };
    }
    listResourceUsagePagingPage(resourceGroupName, profileName, endpointName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listResourceUsagePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listResourceUsage(resourceGroupName, profileName, endpointName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listResourceUsageNext(resourceGroupName, profileName, endpointName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listResourceUsagePagingAll(resourceGroupName, profileName, endpointName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listResourceUsagePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listResourceUsagePagingPage(resourceGroupName, profileName, endpointName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists existing AzureFrontDoor endpoints.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param options The options parameters.
     */
    _listByProfile(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, listByProfileOperationSpec$5);
    }
    /**
     * Gets an existing AzureFrontDoor endpoint with the specified endpoint name under the specified
     * subscription, resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, options }, getOperationSpec$d);
    }
    /**
     * Creates a new AzureFrontDoor endpoint with the specified endpoint name under the specified
     * subscription, resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpoint Endpoint properties
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, profileName, endpointName, endpoint, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, endpointName, endpoint, options }, createOperationSpec$c);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new AzureFrontDoor endpoint with the specified endpoint name under the specified
     * subscription, resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpoint Endpoint properties
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, profileName, endpointName, endpoint, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, profileName, endpointName, endpoint, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing AzureFrontDoor endpoint with the specified endpoint name under the specified
     * subscription, resource group and profile. Only tags can be updated after creating an endpoint. To
     * update origins, use the Update Origin operation. To update origin groups, use the Update Origin
     * group operation. To update domains, use the Update Custom Domain operation.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpointUpdateProperties Endpoint update properties
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, profileName, endpointName, endpointUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                endpointUpdateProperties,
                options
            }, updateOperationSpec$9);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an existing AzureFrontDoor endpoint with the specified endpoint name under the specified
     * subscription, resource group and profile. Only tags can be updated after creating an endpoint. To
     * update origins, use the Update Origin operation. To update origin groups, use the Update Origin
     * group operation. To update domains, use the Update Custom Domain operation.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpointUpdateProperties Endpoint update properties
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, profileName, endpointName, endpointUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, profileName, endpointName, endpointUpdateProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing AzureFrontDoor endpoint with the specified endpoint name under the specified
     * subscription, resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, endpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, endpointName, options }, deleteOperationSpec$d);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing AzureFrontDoor endpoint with the specified endpoint name under the specified
     * subscription, resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, endpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, endpointName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Removes a content from AzureFrontDoor.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contents The list of paths to the content and the list of linked domains to be purged. Path
     *                 can be a full URL, e.g. '/pictures/city.png' which removes a single file, or a directory with a
     *                 wildcard, e.g. '/pictures/*' which removes all folders and files in the directory.
     * @param options The options parameters.
     */
    beginPurgeContent(resourceGroupName, profileName, endpointName, contents, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, endpointName, contents, options }, purgeContentOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Removes a content from AzureFrontDoor.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contents The list of paths to the content and the list of linked domains to be purged. Path
     *                 can be a full URL, e.g. '/pictures/city.png' which removes a single file, or a directory with a
     *                 wildcard, e.g. '/pictures/*' which removes all folders and files in the directory.
     * @param options The options parameters.
     */
    beginPurgeContentAndWait(resourceGroupName, profileName, endpointName, contents, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPurgeContent(resourceGroupName, profileName, endpointName, contents, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks the quota and actual usage of the given AzureFrontDoor endpoint under the given CDN profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    _listResourceUsage(resourceGroupName, profileName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, options }, listResourceUsageOperationSpec$4);
    }
    /**
     * Validates the custom domain mapping to ensure it maps to the correct CDN endpoint in DNS.This api
     * isn't work for apex domain.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param customDomainProperties Custom domain to be validated.
     * @param options The options parameters.
     */
    validateCustomDomain(resourceGroupName, profileName, endpointName, customDomainProperties, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            profileName,
            endpointName,
            customDomainProperties,
            options
        }, validateCustomDomainOperationSpec$1);
    }
    /**
     * ListByProfileNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByProfile method.
     * @param options The options parameters.
     */
    _listByProfileNext(resourceGroupName, profileName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, nextLink, options }, listByProfileNextOperationSpec$5);
    }
    /**
     * ListResourceUsageNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param nextLink The nextLink from the previous successful call to the ListResourceUsage method.
     * @param options The options parameters.
     */
    _listResourceUsageNext(resourceGroupName, profileName, endpointName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, nextLink, options }, listResourceUsageNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$k = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByProfileOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/afdEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AFDEndpointListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/afdEndpoints/{endpointName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AFDEndpoint
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const createOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/afdEndpoints/{endpointName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AFDEndpoint
        },
        201: {
            bodyMapper: AFDEndpoint
        },
        202: {
            bodyMapper: AFDEndpoint
        },
        204: {
            bodyMapper: AFDEndpoint
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: endpoint,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$k
};
const updateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/afdEndpoints/{endpointName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AFDEndpoint
        },
        201: {
            bodyMapper: AFDEndpoint
        },
        202: {
            bodyMapper: AFDEndpoint
        },
        204: {
            bodyMapper: AFDEndpoint
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: endpointUpdateProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$k
};
const deleteOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/afdEndpoints/{endpointName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const purgeContentOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/afdEndpoints/{endpointName}/purge",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: contents,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$k
};
const listResourceUsageOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/afdEndpoints/{endpointName}/usages",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: UsagesListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const validateCustomDomainOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/afdEndpoints/{endpointName}/validateCustomDomain",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ValidateCustomDomainOutput
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: customDomainProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$k
};
const listByProfileNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AFDEndpointListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listResourceUsageNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsagesListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AfdOriginGroups operations. */
class AfdOriginGroupsImpl {
    /**
     * Initialize a new instance of the class AfdOriginGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the existing origin groups within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param options The options parameters.
     */
    listByProfile(resourceGroupName, profileName, options) {
        const iter = this.listByProfilePagingAll(resourceGroupName, profileName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByProfilePagingPage(resourceGroupName, profileName, options, settings);
            }
        };
    }
    listByProfilePagingPage(resourceGroupName, profileName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByProfile(resourceGroupName, profileName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByProfileNext(resourceGroupName, profileName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByProfilePagingAll(resourceGroupName, profileName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByProfilePagingPage(resourceGroupName, profileName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Checks the quota and actual usage of the given AzureFrontDoor origin group under the given CDN
     * profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the endpoint.
     * @param options The options parameters.
     */
    listResourceUsage(resourceGroupName, profileName, originGroupName, options) {
        const iter = this.listResourceUsagePagingAll(resourceGroupName, profileName, originGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listResourceUsagePagingPage(resourceGroupName, profileName, originGroupName, options, settings);
            }
        };
    }
    listResourceUsagePagingPage(resourceGroupName, profileName, originGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listResourceUsagePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listResourceUsage(resourceGroupName, profileName, originGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listResourceUsageNext(resourceGroupName, profileName, originGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listResourceUsagePagingAll(resourceGroupName, profileName, originGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listResourceUsagePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listResourceUsagePagingPage(resourceGroupName, profileName, originGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all of the existing origin groups within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param options The options parameters.
     */
    _listByProfile(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, listByProfileOperationSpec$4);
    }
    /**
     * Gets an existing origin group within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the endpoint.
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, originGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, originGroupName, options }, getOperationSpec$c);
    }
    /**
     * Creates a new origin group within the specified profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the endpoint.
     * @param originGroup Origin group properties
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, profileName, originGroupName, originGroup, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, originGroupName, originGroup, options }, createOperationSpec$b);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new origin group within the specified profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the endpoint.
     * @param originGroup Origin group properties
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, profileName, originGroupName, originGroup, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, profileName, originGroupName, originGroup, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing origin group within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the profile.
     * @param originGroupUpdateProperties Origin group properties
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, profileName, originGroupName, originGroupUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                originGroupName,
                originGroupUpdateProperties,
                options
            }, updateOperationSpec$8);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an existing origin group within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the profile.
     * @param originGroupUpdateProperties Origin group properties
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, profileName, originGroupName, originGroupUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, profileName, originGroupName, originGroupUpdateProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing origin group within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the profile.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, originGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, originGroupName, options }, deleteOperationSpec$c);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing origin group within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the profile.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, originGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, originGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks the quota and actual usage of the given AzureFrontDoor origin group under the given CDN
     * profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the endpoint.
     * @param options The options parameters.
     */
    _listResourceUsage(resourceGroupName, profileName, originGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, originGroupName, options }, listResourceUsageOperationSpec$3);
    }
    /**
     * ListByProfileNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByProfile method.
     * @param options The options parameters.
     */
    _listByProfileNext(resourceGroupName, profileName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, nextLink, options }, listByProfileNextOperationSpec$4);
    }
    /**
     * ListResourceUsageNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the endpoint.
     * @param nextLink The nextLink from the previous successful call to the ListResourceUsage method.
     * @param options The options parameters.
     */
    _listResourceUsageNext(resourceGroupName, profileName, originGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, originGroupName, nextLink, options }, listResourceUsageNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByProfileOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/originGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AFDOriginGroupListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/originGroups/{originGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AFDOriginGroup
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        originGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const createOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/originGroups/{originGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AFDOriginGroup
        },
        201: {
            bodyMapper: AFDOriginGroup
        },
        202: {
            bodyMapper: AFDOriginGroup
        },
        204: {
            bodyMapper: AFDOriginGroup
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: originGroup,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        originGroupName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$j
};
const updateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/originGroups/{originGroupName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AFDOriginGroup
        },
        201: {
            bodyMapper: AFDOriginGroup
        },
        202: {
            bodyMapper: AFDOriginGroup
        },
        204: {
            bodyMapper: AFDOriginGroup
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: originGroupUpdateProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        originGroupName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$j
};
const deleteOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/originGroups/{originGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        originGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listResourceUsageOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/originGroups/{originGroupName}/usages",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: UsagesListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        originGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listByProfileNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AFDOriginGroupListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listResourceUsageNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsagesListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink,
        originGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AfdOrigins operations. */
class AfdOriginsImpl {
    /**
     * Initialize a new instance of the class AfdOrigins class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the existing origins within an origin group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the profile.
     * @param options The options parameters.
     */
    listByOriginGroup(resourceGroupName, profileName, originGroupName, options) {
        const iter = this.listByOriginGroupPagingAll(resourceGroupName, profileName, originGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByOriginGroupPagingPage(resourceGroupName, profileName, originGroupName, options, settings);
            }
        };
    }
    listByOriginGroupPagingPage(resourceGroupName, profileName, originGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByOriginGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByOriginGroup(resourceGroupName, profileName, originGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByOriginGroupNext(resourceGroupName, profileName, originGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByOriginGroupPagingAll(resourceGroupName, profileName, originGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByOriginGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByOriginGroupPagingPage(resourceGroupName, profileName, originGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the existing origins within an origin group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the profile.
     * @param options The options parameters.
     */
    _listByOriginGroup(resourceGroupName, profileName, originGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, originGroupName, options }, listByOriginGroupOperationSpec);
    }
    /**
     * Gets an existing origin within an origin group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the profile.
     * @param originName Name of the origin which is unique within the profile.
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, originGroupName, originName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, originGroupName, originName, options }, getOperationSpec$b);
    }
    /**
     * Creates a new origin within the specified origin group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the profile.
     * @param originName Name of the origin that is unique within the profile.
     * @param origin Origin properties
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, profileName, originGroupName, originName, origin, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                originGroupName,
                originName,
                origin,
                options
            }, createOperationSpec$a);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new origin within the specified origin group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the profile.
     * @param originName Name of the origin that is unique within the profile.
     * @param origin Origin properties
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, profileName, originGroupName, originName, origin, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, profileName, originGroupName, originName, origin, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing origin within an origin group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the profile.
     * @param originName Name of the origin which is unique within the profile.
     * @param originUpdateProperties Origin properties
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, profileName, originGroupName, originName, originUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                originGroupName,
                originName,
                originUpdateProperties,
                options
            }, updateOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an existing origin within an origin group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the profile.
     * @param originName Name of the origin which is unique within the profile.
     * @param originUpdateProperties Origin properties
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, profileName, originGroupName, originName, originUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, profileName, originGroupName, originName, originUpdateProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing origin within an origin group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the profile.
     * @param originName Name of the origin which is unique within the profile.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, originGroupName, originName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, originGroupName, originName, options }, deleteOperationSpec$b);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing origin within an origin group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the profile.
     * @param originName Name of the origin which is unique within the profile.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, originGroupName, originName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, originGroupName, originName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByOriginGroupNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param originGroupName Name of the origin group which is unique within the profile.
     * @param nextLink The nextLink from the previous successful call to the ListByOriginGroup method.
     * @param options The options parameters.
     */
    _listByOriginGroupNext(resourceGroupName, profileName, originGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, originGroupName, nextLink, options }, listByOriginGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByOriginGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/originGroups/{originGroupName}/origins",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AFDOriginListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        originGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/originGroups/{originGroupName}/origins/{originName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AFDOrigin
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        originGroupName,
        originName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const createOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/originGroups/{originGroupName}/origins/{originName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AFDOrigin
        },
        201: {
            bodyMapper: AFDOrigin
        },
        202: {
            bodyMapper: AFDOrigin
        },
        204: {
            bodyMapper: AFDOrigin
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: origin,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        originGroupName,
        originName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$i
};
const updateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/originGroups/{originGroupName}/origins/{originName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AFDOrigin
        },
        201: {
            bodyMapper: AFDOrigin
        },
        202: {
            bodyMapper: AFDOrigin
        },
        204: {
            bodyMapper: AFDOrigin
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: originUpdateProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        originGroupName,
        originName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$i
};
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/originGroups/{originGroupName}/origins/{originName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        originGroupName,
        originName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listByOriginGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AFDOriginListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink,
        originGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Routes operations. */
class RoutesImpl {
    /**
     * Initialize a new instance of the class Routes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the existing origins within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    listByEndpoint(resourceGroupName, profileName, endpointName, options) {
        const iter = this.listByEndpointPagingAll(resourceGroupName, profileName, endpointName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByEndpointPagingPage(resourceGroupName, profileName, endpointName, options, settings);
            }
        };
    }
    listByEndpointPagingPage(resourceGroupName, profileName, endpointName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByEndpointPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByEndpoint(resourceGroupName, profileName, endpointName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByEndpointNext(resourceGroupName, profileName, endpointName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByEndpointPagingAll(resourceGroupName, profileName, endpointName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByEndpointPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByEndpointPagingPage(resourceGroupName, profileName, endpointName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the existing origins within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    _listByEndpoint(resourceGroupName, profileName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, options }, listByEndpointOperationSpec$3);
    }
    /**
     * Gets an existing route with the specified route name under the specified subscription, resource
     * group, profile, and AzureFrontDoor endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param routeName Name of the routing rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, endpointName, routeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, routeName, options }, getOperationSpec$a);
    }
    /**
     * Creates a new route with the specified route name under the specified subscription, resource group,
     * profile, and AzureFrontDoor endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param routeName Name of the routing rule.
     * @param route Route properties
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, profileName, endpointName, routeName, route, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                routeName,
                route,
                options
            }, createOperationSpec$9);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new route with the specified route name under the specified subscription, resource group,
     * profile, and AzureFrontDoor endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param routeName Name of the routing rule.
     * @param route Route properties
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, profileName, endpointName, routeName, route, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, profileName, endpointName, routeName, route, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing route with the specified route name under the specified subscription, resource
     * group, profile, and AzureFrontDoor endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param routeName Name of the routing rule.
     * @param routeUpdateProperties Route update properties
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, profileName, endpointName, routeName, routeUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                routeName,
                routeUpdateProperties,
                options
            }, updateOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an existing route with the specified route name under the specified subscription, resource
     * group, profile, and AzureFrontDoor endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param routeName Name of the routing rule.
     * @param routeUpdateProperties Route update properties
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, profileName, endpointName, routeName, routeUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, profileName, endpointName, routeName, routeUpdateProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing route with the specified route name under the specified subscription, resource
     * group, profile, and AzureFrontDoor endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param routeName Name of the routing rule.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, endpointName, routeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, endpointName, routeName, options }, deleteOperationSpec$a);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing route with the specified route name under the specified subscription, resource
     * group, profile, and AzureFrontDoor endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param routeName Name of the routing rule.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, endpointName, routeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, endpointName, routeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByEndpointNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param nextLink The nextLink from the previous successful call to the ListByEndpoint method.
     * @param options The options parameters.
     */
    _listByEndpointNext(resourceGroupName, profileName, endpointName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, nextLink, options }, listByEndpointNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByEndpointOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/afdEndpoints/{endpointName}/routes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/afdEndpoints/{endpointName}/routes/{routeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Route
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName,
        routeName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const createOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/afdEndpoints/{endpointName}/routes/{routeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Route
        },
        201: {
            bodyMapper: Route
        },
        202: {
            bodyMapper: Route
        },
        204: {
            bodyMapper: Route
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: route,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName,
        routeName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$h
};
const updateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/afdEndpoints/{endpointName}/routes/{routeName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Route
        },
        201: {
            bodyMapper: Route
        },
        202: {
            bodyMapper: Route
        },
        204: {
            bodyMapper: Route
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: routeUpdateProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName,
        routeName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$h
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/afdEndpoints/{endpointName}/routes/{routeName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName,
        routeName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listByEndpointNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RuleSets operations. */
class RuleSetsImpl {
    /**
     * Initialize a new instance of the class RuleSets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists existing AzureFrontDoor rule sets within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param options The options parameters.
     */
    listByProfile(resourceGroupName, profileName, options) {
        const iter = this.listByProfilePagingAll(resourceGroupName, profileName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByProfilePagingPage(resourceGroupName, profileName, options, settings);
            }
        };
    }
    listByProfilePagingPage(resourceGroupName, profileName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByProfile(resourceGroupName, profileName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByProfileNext(resourceGroupName, profileName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByProfilePagingAll(resourceGroupName, profileName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByProfilePagingPage(resourceGroupName, profileName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Checks the quota and actual usage of the given AzureFrontDoor rule set under the given CDN profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile which is unique globally.
     * @param options The options parameters.
     */
    listResourceUsage(resourceGroupName, profileName, ruleSetName, options) {
        const iter = this.listResourceUsagePagingAll(resourceGroupName, profileName, ruleSetName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listResourceUsagePagingPage(resourceGroupName, profileName, ruleSetName, options, settings);
            }
        };
    }
    listResourceUsagePagingPage(resourceGroupName, profileName, ruleSetName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listResourceUsagePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listResourceUsage(resourceGroupName, profileName, ruleSetName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listResourceUsageNext(resourceGroupName, profileName, ruleSetName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listResourceUsagePagingAll(resourceGroupName, profileName, ruleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listResourceUsagePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listResourceUsagePagingPage(resourceGroupName, profileName, ruleSetName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists existing AzureFrontDoor rule sets within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param options The options parameters.
     */
    _listByProfile(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, listByProfileOperationSpec$3);
    }
    /**
     * Gets an existing AzureFrontDoor rule set with the specified rule set name under the specified
     * subscription, resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile which is unique globally.
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, ruleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, ruleSetName, options }, getOperationSpec$9);
    }
    /**
     * Creates a new rule set within the specified profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile which is unique globally
     * @param options The options parameters.
     */
    create(resourceGroupName, profileName, ruleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, ruleSetName, options }, createOperationSpec$8);
    }
    /**
     * Deletes an existing AzureFrontDoor rule set with the specified rule set name under the specified
     * subscription, resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile which is unique globally.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, ruleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, ruleSetName, options }, deleteOperationSpec$9);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing AzureFrontDoor rule set with the specified rule set name under the specified
     * subscription, resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile which is unique globally.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, ruleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, ruleSetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks the quota and actual usage of the given AzureFrontDoor rule set under the given CDN profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile which is unique globally.
     * @param options The options parameters.
     */
    _listResourceUsage(resourceGroupName, profileName, ruleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, ruleSetName, options }, listResourceUsageOperationSpec$2);
    }
    /**
     * ListByProfileNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByProfile method.
     * @param options The options parameters.
     */
    _listByProfileNext(resourceGroupName, profileName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, nextLink, options }, listByProfileNextOperationSpec$3);
    }
    /**
     * ListResourceUsageNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile which is unique globally.
     * @param nextLink The nextLink from the previous successful call to the ListResourceUsage method.
     * @param options The options parameters.
     */
    _listResourceUsageNext(resourceGroupName, profileName, ruleSetName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, ruleSetName, nextLink, options }, listResourceUsageNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByProfileOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/ruleSets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RuleSetListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/ruleSets/{ruleSetName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RuleSet
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        ruleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const createOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/ruleSets/{ruleSetName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RuleSet
        },
        201: {
            bodyMapper: RuleSet
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        ruleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/ruleSets/{ruleSetName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        ruleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listResourceUsageOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/ruleSets/{ruleSetName}/usages",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: UsagesListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        ruleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listByProfileNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RuleSetListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listResourceUsageNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsagesListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink,
        ruleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Rules operations. */
class RulesImpl {
    /**
     * Initialize a new instance of the class Rules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the existing delivery rules within a rule set.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile.
     * @param options The options parameters.
     */
    listByRuleSet(resourceGroupName, profileName, ruleSetName, options) {
        const iter = this.listByRuleSetPagingAll(resourceGroupName, profileName, ruleSetName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByRuleSetPagingPage(resourceGroupName, profileName, ruleSetName, options, settings);
            }
        };
    }
    listByRuleSetPagingPage(resourceGroupName, profileName, ruleSetName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByRuleSetPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByRuleSet(resourceGroupName, profileName, ruleSetName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByRuleSetNext(resourceGroupName, profileName, ruleSetName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByRuleSetPagingAll(resourceGroupName, profileName, ruleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByRuleSetPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByRuleSetPagingPage(resourceGroupName, profileName, ruleSetName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the existing delivery rules within a rule set.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile.
     * @param options The options parameters.
     */
    _listByRuleSet(resourceGroupName, profileName, ruleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, ruleSetName, options }, listByRuleSetOperationSpec);
    }
    /**
     * Gets an existing delivery rule within a rule set.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile.
     * @param ruleName Name of the delivery rule which is unique within the endpoint.
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, ruleSetName, ruleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, ruleSetName, ruleName, options }, getOperationSpec$8);
    }
    /**
     * Creates a new delivery rule within the specified rule set.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile.
     * @param ruleName Name of the delivery rule which is unique within the endpoint.
     * @param rule The delivery rule properties.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, profileName, ruleSetName, ruleName, rule, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, ruleSetName, ruleName, rule, options }, createOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new delivery rule within the specified rule set.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile.
     * @param ruleName Name of the delivery rule which is unique within the endpoint.
     * @param rule The delivery rule properties.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, profileName, ruleSetName, ruleName, rule, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, profileName, ruleSetName, ruleName, rule, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing delivery rule within a rule set.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile.
     * @param ruleName Name of the delivery rule which is unique within the endpoint.
     * @param ruleUpdateProperties Delivery rule properties
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, profileName, ruleSetName, ruleName, ruleUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                ruleSetName,
                ruleName,
                ruleUpdateProperties,
                options
            }, updateOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an existing delivery rule within a rule set.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile.
     * @param ruleName Name of the delivery rule which is unique within the endpoint.
     * @param ruleUpdateProperties Delivery rule properties
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, profileName, ruleSetName, ruleName, ruleUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, profileName, ruleSetName, ruleName, ruleUpdateProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing delivery rule within a rule set.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile.
     * @param ruleName Name of the delivery rule which is unique within the endpoint.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, ruleSetName, ruleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, ruleSetName, ruleName, options }, deleteOperationSpec$8);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing delivery rule within a rule set.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile.
     * @param ruleName Name of the delivery rule which is unique within the endpoint.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, ruleSetName, ruleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, ruleSetName, ruleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByRuleSetNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param ruleSetName Name of the rule set under the profile.
     * @param nextLink The nextLink from the previous successful call to the ListByRuleSet method.
     * @param options The options parameters.
     */
    _listByRuleSetNext(resourceGroupName, profileName, ruleSetName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, ruleSetName, nextLink, options }, listByRuleSetNextOperationSpec);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByRuleSetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/ruleSets/{ruleSetName}/rules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RuleListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        ruleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/ruleSets/{ruleSetName}/rules/{ruleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Rule
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        ruleSetName,
        ruleName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const createOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/ruleSets/{ruleSetName}/rules/{ruleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Rule
        },
        201: {
            bodyMapper: Rule
        },
        202: {
            bodyMapper: Rule
        },
        204: {
            bodyMapper: Rule
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: rule,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        ruleSetName,
        ruleName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$f
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/ruleSets/{ruleSetName}/rules/{ruleName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Rule
        },
        201: {
            bodyMapper: Rule
        },
        202: {
            bodyMapper: Rule
        },
        204: {
            bodyMapper: Rule
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: ruleUpdateProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        ruleSetName,
        ruleName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$f
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/ruleSets/{ruleSetName}/rules/{ruleName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        ruleSetName,
        ruleName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByRuleSetNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RuleListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink,
        ruleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SecurityPolicies operations. */
class SecurityPoliciesImpl {
    /**
     * Initialize a new instance of the class SecurityPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists security policies associated with the profile
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param options The options parameters.
     */
    listByProfile(resourceGroupName, profileName, options) {
        const iter = this.listByProfilePagingAll(resourceGroupName, profileName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByProfilePagingPage(resourceGroupName, profileName, options, settings);
            }
        };
    }
    listByProfilePagingPage(resourceGroupName, profileName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByProfile(resourceGroupName, profileName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByProfileNext(resourceGroupName, profileName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByProfilePagingAll(resourceGroupName, profileName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByProfilePagingPage(resourceGroupName, profileName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists security policies associated with the profile
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param options The options parameters.
     */
    _listByProfile(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, listByProfileOperationSpec$2);
    }
    /**
     * Gets an existing security policy within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param securityPolicyName Name of the security policy under the profile.
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, securityPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, securityPolicyName, options }, getOperationSpec$7);
    }
    /**
     * Creates a new security policy within the specified profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param securityPolicyName Name of the security policy under the profile.
     * @param securityPolicy The security policy properties.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, profileName, securityPolicyName, securityPolicy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                securityPolicyName,
                securityPolicy,
                options
            }, createOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new security policy within the specified profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param securityPolicyName Name of the security policy under the profile.
     * @param securityPolicy The security policy properties.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, profileName, securityPolicyName, securityPolicy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, profileName, securityPolicyName, securityPolicy, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing security policy within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param securityPolicyName Name of the security policy under the profile.
     * @param securityPolicyUpdateProperties Security policy update properties
     * @param options The options parameters.
     */
    beginPatch(resourceGroupName, profileName, securityPolicyName, securityPolicyUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                securityPolicyName,
                securityPolicyUpdateProperties,
                options
            }, patchOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an existing security policy within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param securityPolicyName Name of the security policy under the profile.
     * @param securityPolicyUpdateProperties Security policy update properties
     * @param options The options parameters.
     */
    beginPatchAndWait(resourceGroupName, profileName, securityPolicyName, securityPolicyUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPatch(resourceGroupName, profileName, securityPolicyName, securityPolicyUpdateProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing security policy within profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param securityPolicyName Name of the security policy under the profile.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, securityPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, securityPolicyName, options }, deleteOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing security policy within profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param securityPolicyName Name of the security policy under the profile.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, securityPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, securityPolicyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByProfileNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByProfile method.
     * @param options The options parameters.
     */
    _listByProfileNext(resourceGroupName, profileName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, nextLink, options }, listByProfileNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByProfileOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/securityPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityPolicyListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/securityPolicies/{securityPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityPolicy
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        securityPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const createOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/securityPolicies/{securityPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SecurityPolicy
        },
        201: {
            bodyMapper: SecurityPolicy
        },
        202: {
            bodyMapper: SecurityPolicy
        },
        204: {
            bodyMapper: SecurityPolicy
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: securityPolicy,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        securityPolicyName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$e
};
const patchOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/securityPolicies/{securityPolicyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SecurityPolicy
        },
        201: {
            bodyMapper: SecurityPolicy
        },
        202: {
            bodyMapper: SecurityPolicy
        },
        204: {
            bodyMapper: SecurityPolicy
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: securityPolicyUpdateProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        securityPolicyName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$e
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/securityPolicies/{securityPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        securityPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const listByProfileNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityPolicyListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Secrets operations. */
class SecretsImpl {
    /**
     * Initialize a new instance of the class Secrets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists existing AzureFrontDoor secrets.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param options The options parameters.
     */
    listByProfile(resourceGroupName, profileName, options) {
        const iter = this.listByProfilePagingAll(resourceGroupName, profileName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByProfilePagingPage(resourceGroupName, profileName, options, settings);
            }
        };
    }
    listByProfilePagingPage(resourceGroupName, profileName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByProfile(resourceGroupName, profileName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByProfileNext(resourceGroupName, profileName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByProfilePagingAll(resourceGroupName, profileName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByProfilePagingPage(resourceGroupName, profileName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists existing AzureFrontDoor secrets.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param options The options parameters.
     */
    _listByProfile(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, listByProfileOperationSpec$1);
    }
    /**
     * Gets an existing Secret within a profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param secretName Name of the Secret under the profile.
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, secretName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, secretName, options }, getOperationSpec$6);
    }
    /**
     * Creates a new Secret within the specified profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param secretName Name of the Secret under the profile.
     * @param secret The Secret properties.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, profileName, secretName, secret, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, secretName, secret, options }, createOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new Secret within the specified profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param secretName Name of the Secret under the profile.
     * @param secret The Secret properties.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, profileName, secretName, secret, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, profileName, secretName, secret, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Secret within profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param secretName Name of the Secret under the profile.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, secretName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, secretName, options }, deleteOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Secret within profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param secretName Name of the Secret under the profile.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, secretName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, secretName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByProfileNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByProfile method.
     * @param options The options parameters.
     */
    _listByProfileNext(resourceGroupName, profileName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, nextLink, options }, listByProfileNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByProfileOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/secrets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/secrets/{secretName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Secret
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        secretName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const createOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/secrets/{secretName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Secret
        },
        201: {
            bodyMapper: Secret
        },
        202: {
            bodyMapper: Secret
        },
        204: {
            bodyMapper: Secret
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: secret,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        secretName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$d
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/secrets/{secretName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        secretName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByProfileNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Validate operations. */
class ValidateImpl {
    /**
     * Initialize a new instance of the class Validate class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Validate a Secret in the profile.
     * @param validateSecretInput The Secret source.
     * @param options The options parameters.
     */
    secret(validateSecretInput, options) {
        return this.client.sendOperationRequest({ validateSecretInput, options }, secretOperationSpec);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const secretOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Cdn/validateSecret",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ValidateSecretOutput
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: validateSecretInput,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing LogAnalytics operations. */
class LogAnalyticsImpl {
    /**
     * Initialize a new instance of the class LogAnalytics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get log report for AFD profile
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group. which is unique within the resource group.
     * @param metrics Array of LogMetric
     * @param dateTimeBegin
     * @param dateTimeEnd
     * @param granularity
     * @param customDomains Array of Get11ItemsItem
     * @param protocols Array of Get12ItemsItem
     * @param options The options parameters.
     */
    getLogAnalyticsMetrics(resourceGroupName, profileName, metrics, dateTimeBegin, dateTimeEnd, granularity, customDomains, protocols, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            profileName,
            metrics,
            dateTimeBegin,
            dateTimeEnd,
            granularity,
            customDomains,
            protocols,
            options
        }, getLogAnalyticsMetricsOperationSpec);
    }
    /**
     * Get log analytics ranking report for AFD profile
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group. which is unique within the resource group.
     * @param rankings Array of LogRanking
     * @param metrics Array of LogRankingMetric
     * @param maxRanking
     * @param dateTimeBegin
     * @param dateTimeEnd
     * @param options The options parameters.
     */
    getLogAnalyticsRankings(resourceGroupName, profileName, rankings, metrics, maxRanking, dateTimeBegin, dateTimeEnd, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            profileName,
            rankings,
            metrics,
            maxRanking,
            dateTimeBegin,
            dateTimeEnd,
            options
        }, getLogAnalyticsRankingsOperationSpec);
    }
    /**
     * Get all available location names for AFD log analytics report.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group. which is unique within the resource group.
     * @param options The options parameters.
     */
    getLogAnalyticsLocations(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, getLogAnalyticsLocationsOperationSpec);
    }
    /**
     * Get all endpoints and custom domains available for AFD log report
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group. which is unique within the resource group.
     * @param options The options parameters.
     */
    getLogAnalyticsResources(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, getLogAnalyticsResourcesOperationSpec);
    }
    /**
     * Get Waf related log analytics report for AFD profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group. which is unique within the resource group.
     * @param metrics Array of WafMetric
     * @param dateTimeBegin
     * @param dateTimeEnd
     * @param granularity
     * @param options The options parameters.
     */
    getWafLogAnalyticsMetrics(resourceGroupName, profileName, metrics, dateTimeBegin, dateTimeEnd, granularity, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            profileName,
            metrics,
            dateTimeBegin,
            dateTimeEnd,
            granularity,
            options
        }, getWafLogAnalyticsMetricsOperationSpec);
    }
    /**
     * Get WAF log analytics charts for AFD profile
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium profile which
     *                    is unique within the resource group. which is unique within the resource group.
     * @param metrics Array of WafMetric
     * @param dateTimeBegin
     * @param dateTimeEnd
     * @param maxRanking
     * @param rankings Array of WafRankingType
     * @param options The options parameters.
     */
    getWafLogAnalyticsRankings(resourceGroupName, profileName, metrics, dateTimeBegin, dateTimeEnd, maxRanking, rankings, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            profileName,
            metrics,
            dateTimeBegin,
            dateTimeEnd,
            maxRanking,
            rankings,
            options
        }, getWafLogAnalyticsRankingsOperationSpec);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getLogAnalyticsMetricsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/getLogAnalyticsMetrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricsResponse
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        metrics,
        dateTimeBegin,
        dateTimeEnd,
        granularity,
        groupBy,
        continents,
        countryOrRegions,
        customDomains,
        protocols
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getLogAnalyticsRankingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/getLogAnalyticsRankings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RankingsResponse
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        dateTimeBegin,
        dateTimeEnd,
        rankings,
        metrics1,
        maxRanking,
        customDomains1
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getLogAnalyticsLocationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/getLogAnalyticsLocations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContinentsResponse
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getLogAnalyticsResourcesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/getLogAnalyticsResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourcesResponse
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getWafLogAnalyticsMetricsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/getWafLogAnalyticsMetrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WafMetricsResponse
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        dateTimeBegin,
        dateTimeEnd,
        metrics2,
        granularity1,
        actions,
        groupBy1,
        ruleTypes
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getWafLogAnalyticsRankingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/getWafLogAnalyticsRankings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WafRankingsResponse
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        dateTimeBegin,
        dateTimeEnd,
        maxRanking,
        metrics2,
        actions,
        ruleTypes,
        rankings1
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Profiles operations. */
class ProfilesImpl {
    /**
     * Initialize a new instance of the class Profiles class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the Azure Front Door Standard, Azure Front Door Premium, and CDN profiles within an
     * Azure subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the Azure Front Door Standard, Azure Front Door Premium, and CDN profiles within a
     * resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Checks the quota and actual usage of endpoints under the given Azure Front Door Standard or Azure
     * Front Door Premium or CDN profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param options The options parameters.
     */
    listResourceUsage(resourceGroupName, profileName, options) {
        const iter = this.listResourceUsagePagingAll(resourceGroupName, profileName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listResourceUsagePagingPage(resourceGroupName, profileName, options, settings);
            }
        };
    }
    listResourceUsagePagingPage(resourceGroupName, profileName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listResourceUsagePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listResourceUsage(resourceGroupName, profileName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listResourceUsageNext(resourceGroupName, profileName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listResourceUsagePagingAll(resourceGroupName, profileName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listResourceUsagePagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listResourceUsagePagingPage(resourceGroupName, profileName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Lists all of the Azure Front Door Standard, Azure Front Door Premium, and CDN profiles within an
     * Azure subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$5);
    }
    /**
     * Lists all of the Azure Front Door Standard, Azure Front Door Premium, and CDN profiles within a
     * resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Gets an Azure Front Door Standard or Azure Front Door Premium or CDN profile with the specified
     * profile name under the specified subscription and resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, getOperationSpec$5);
    }
    /**
     * Creates a new Azure Front Door Standard or Azure Front Door Premium or CDN profile with a profile
     * name under the specified subscription and resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param profile Profile properties needed to create a new profile.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, profileName, profile, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, profile, options }, createOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new Azure Front Door Standard or Azure Front Door Premium or CDN profile with a profile
     * name under the specified subscription and resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param profile Profile properties needed to create a new profile.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, profileName, profile, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, profileName, profile, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing Azure Front Door Standard or Azure Front Door Premium or CDN profile with the
     * specified profile name under the specified subscription and resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param profileUpdateParameters Profile properties needed to update an existing profile.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, profileName, profileUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, profileUpdateParameters, options }, updateOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an existing Azure Front Door Standard or Azure Front Door Premium or CDN profile with the
     * specified profile name under the specified subscription and resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param profileUpdateParameters Profile properties needed to update an existing profile.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, profileName, profileUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, profileName, profileUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing  Azure Front Door Standard or Azure Front Door Premium or CDN profile with the
     * specified parameters. Deleting a profile will result in the deletion of all of the sub-resources
     * including endpoints, origins and custom domains.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, options }, deleteOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing  Azure Front Door Standard or Azure Front Door Premium or CDN profile with the
     * specified parameters. Deleting a profile will result in the deletion of all of the sub-resources
     * including endpoints, origins and custom domains.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Generates a dynamic SSO URI used to sign in to the CDN supplemental portal. Supplemental portal is
     * used to configure advanced feature capabilities that are not yet available in the Azure portal, such
     * as core reports in a standard profile; rules engine, advanced HTTP reports, and real-time stats and
     * alerts in a premium profile. The SSO URI changes approximately every 10 minutes.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param options The options parameters.
     */
    generateSsoUri(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, generateSsoUriOperationSpec);
    }
    /**
     * Gets the supported optimization types for the current profile. A user can create an endpoint with an
     * optimization type from the listed values.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param options The options parameters.
     */
    listSupportedOptimizationTypes(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, listSupportedOptimizationTypesOperationSpec);
    }
    /**
     * Checks the quota and actual usage of endpoints under the given Azure Front Door Standard or Azure
     * Front Door Premium or CDN profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param options The options parameters.
     */
    _listResourceUsage(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, listResourceUsageOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$5);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListResourceUsageNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the Azure Front Door Standard or Azure Front Door Premium or CDN profile
     *                    which is unique within the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListResourceUsage method.
     * @param options The options parameters.
     */
    _listResourceUsageNext(resourceGroupName, profileName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, nextLink, options }, listResourceUsageNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Cdn/profiles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProfileListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$a
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProfileListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Profile
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Profile
        },
        201: {
            bodyMapper: Profile
        },
        202: {
            bodyMapper: Profile
        },
        204: {
            bodyMapper: Profile
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: profile,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$a
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Profile
        },
        201: {
            bodyMapper: Profile
        },
        202: {
            bodyMapper: Profile
        },
        204: {
            bodyMapper: Profile
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: profileUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$a
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const generateSsoUriOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/generateSsoUri",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SsoUri
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSupportedOptimizationTypesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/getSupportedOptimizationTypes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SupportedOptimizationTypesListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listResourceUsageOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/checkResourceUsage",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ResourceUsageListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProfileListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProfileListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listResourceUsageNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceUsageListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Endpoints operations. */
class EndpointsImpl {
    /**
     * Initialize a new instance of the class Endpoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists existing CDN endpoints.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param options The options parameters.
     */
    listByProfile(resourceGroupName, profileName, options) {
        const iter = this.listByProfilePagingAll(resourceGroupName, profileName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByProfilePagingPage(resourceGroupName, profileName, options, settings);
            }
        };
    }
    listByProfilePagingPage(resourceGroupName, profileName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByProfile(resourceGroupName, profileName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByProfileNext(resourceGroupName, profileName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByProfilePagingAll(resourceGroupName, profileName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByProfilePagingPage(resourceGroupName, profileName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Checks the quota and usage of geo filters and custom domains under the given endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    listResourceUsage(resourceGroupName, profileName, endpointName, options) {
        const iter = this.listResourceUsagePagingAll(resourceGroupName, profileName, endpointName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listResourceUsagePagingPage(resourceGroupName, profileName, endpointName, options, settings);
            }
        };
    }
    listResourceUsagePagingPage(resourceGroupName, profileName, endpointName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listResourceUsagePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listResourceUsage(resourceGroupName, profileName, endpointName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listResourceUsageNext(resourceGroupName, profileName, endpointName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listResourceUsagePagingAll(resourceGroupName, profileName, endpointName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listResourceUsagePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listResourceUsagePagingPage(resourceGroupName, profileName, endpointName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists existing CDN endpoints.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param options The options parameters.
     */
    _listByProfile(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, listByProfileOperationSpec);
    }
    /**
     * Gets an existing CDN endpoint with the specified endpoint name under the specified subscription,
     * resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, options }, getOperationSpec$4);
    }
    /**
     * Creates a new CDN endpoint with the specified endpoint name under the specified subscription,
     * resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpoint Endpoint properties
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, profileName, endpointName, endpoint, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, endpointName, endpoint, options }, createOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new CDN endpoint with the specified endpoint name under the specified subscription,
     * resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpoint Endpoint properties
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, profileName, endpointName, endpoint, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, profileName, endpointName, endpoint, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing CDN endpoint with the specified endpoint name under the specified subscription,
     * resource group and profile. Only tags can be updated after creating an endpoint. To update origins,
     * use the Update Origin operation. To update origin groups, use the Update Origin group operation. To
     * update custom domains, use the Update Custom Domain operation.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpointUpdateProperties Endpoint update properties
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, profileName, endpointName, endpointUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                endpointUpdateProperties,
                options
            }, updateOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an existing CDN endpoint with the specified endpoint name under the specified subscription,
     * resource group and profile. Only tags can be updated after creating an endpoint. To update origins,
     * use the Update Origin operation. To update origin groups, use the Update Origin group operation. To
     * update custom domains, use the Update Custom Domain operation.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpointUpdateProperties Endpoint update properties
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, profileName, endpointName, endpointUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, profileName, endpointName, endpointUpdateProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing CDN endpoint with the specified endpoint name under the specified subscription,
     * resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, endpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, endpointName, options }, deleteOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing CDN endpoint with the specified endpoint name under the specified subscription,
     * resource group and profile.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, endpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, endpointName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts an existing CDN endpoint that is on a stopped state.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, profileName, endpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, endpointName, options }, startOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts an existing CDN endpoint that is on a stopped state.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, profileName, endpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, profileName, endpointName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops an existing running CDN endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, profileName, endpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, endpointName, options }, stopOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Stops an existing running CDN endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, profileName, endpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, profileName, endpointName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Removes a content from CDN.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentFilePaths The path to the content to be purged. Path can be a full URL, e.g.
     *                         '/pictures/city.png' which removes a single file, or a directory with a wildcard, e.g. '/pictures/*'
     *                         which removes all folders and files in the directory.
     * @param options The options parameters.
     */
    beginPurgeContent(resourceGroupName, profileName, endpointName, contentFilePaths, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                contentFilePaths,
                options
            }, purgeContentOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Removes a content from CDN.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentFilePaths The path to the content to be purged. Path can be a full URL, e.g.
     *                         '/pictures/city.png' which removes a single file, or a directory with a wildcard, e.g. '/pictures/*'
     *                         which removes all folders and files in the directory.
     * @param options The options parameters.
     */
    beginPurgeContentAndWait(resourceGroupName, profileName, endpointName, contentFilePaths, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPurgeContent(resourceGroupName, profileName, endpointName, contentFilePaths, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Pre-loads a content to CDN. Available for Verizon Profiles.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentFilePaths The path to the content to be loaded. Path should be a full URL, e.g.
     *                         ‘/pictures/city.png' which loads a single file
     * @param options The options parameters.
     */
    beginLoadContent(resourceGroupName, profileName, endpointName, contentFilePaths, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                contentFilePaths,
                options
            }, loadContentOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Pre-loads a content to CDN. Available for Verizon Profiles.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentFilePaths The path to the content to be loaded. Path should be a full URL, e.g.
     *                         ‘/pictures/city.png' which loads a single file
     * @param options The options parameters.
     */
    beginLoadContentAndWait(resourceGroupName, profileName, endpointName, contentFilePaths, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginLoadContent(resourceGroupName, profileName, endpointName, contentFilePaths, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Validates the custom domain mapping to ensure it maps to the correct CDN endpoint in DNS.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param customDomainProperties Custom domain to be validated.
     * @param options The options parameters.
     */
    validateCustomDomain(resourceGroupName, profileName, endpointName, customDomainProperties, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            profileName,
            endpointName,
            customDomainProperties,
            options
        }, validateCustomDomainOperationSpec);
    }
    /**
     * Checks the quota and usage of geo filters and custom domains under the given endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    _listResourceUsage(resourceGroupName, profileName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, options }, listResourceUsageOperationSpec);
    }
    /**
     * ListByProfileNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByProfile method.
     * @param options The options parameters.
     */
    _listByProfileNext(resourceGroupName, profileName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, nextLink, options }, listByProfileNextOperationSpec);
    }
    /**
     * ListResourceUsageNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param nextLink The nextLink from the previous successful call to the ListResourceUsage method.
     * @param options The options parameters.
     */
    _listResourceUsageNext(resourceGroupName, profileName, endpointName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, nextLink, options }, listResourceUsageNextOperationSpec);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByProfileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EndpointListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Endpoint
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Endpoint
        },
        201: {
            bodyMapper: Endpoint
        },
        202: {
            bodyMapper: Endpoint
        },
        204: {
            bodyMapper: Endpoint
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: endpoint1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$9
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Endpoint
        },
        201: {
            bodyMapper: Endpoint
        },
        202: {
            bodyMapper: Endpoint
        },
        204: {
            bodyMapper: Endpoint
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: endpointUpdateProperties1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/start",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Endpoint
        },
        201: {
            bodyMapper: Endpoint
        },
        202: {
            bodyMapper: Endpoint
        },
        204: {
            bodyMapper: Endpoint
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/stop",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Endpoint
        },
        201: {
            bodyMapper: Endpoint
        },
        202: {
            bodyMapper: Endpoint
        },
        204: {
            bodyMapper: Endpoint
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const purgeContentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/purge",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: contentFilePaths,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$9
};
const loadContentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/load",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: contentFilePaths1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$9
};
const validateCustomDomainOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/validateCustomDomain",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ValidateCustomDomainOutput
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: customDomainProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$9
};
const listResourceUsageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/checkResourceUsage",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ResourceUsageListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByProfileNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EndpointListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listResourceUsageNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceUsageListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Origins operations. */
class OriginsImpl {
    /**
     * Initialize a new instance of the class Origins class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the existing origins within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    listByEndpoint(resourceGroupName, profileName, endpointName, options) {
        const iter = this.listByEndpointPagingAll(resourceGroupName, profileName, endpointName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByEndpointPagingPage(resourceGroupName, profileName, endpointName, options, settings);
            }
        };
    }
    listByEndpointPagingPage(resourceGroupName, profileName, endpointName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByEndpointPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByEndpoint(resourceGroupName, profileName, endpointName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByEndpointNext(resourceGroupName, profileName, endpointName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByEndpointPagingAll(resourceGroupName, profileName, endpointName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByEndpointPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByEndpointPagingPage(resourceGroupName, profileName, endpointName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the existing origins within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    _listByEndpoint(resourceGroupName, profileName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, options }, listByEndpointOperationSpec$2);
    }
    /**
     * Gets an existing origin within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param originName Name of the origin which is unique within the endpoint.
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, endpointName, originName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, originName, options }, getOperationSpec$3);
    }
    /**
     * Creates a new origin within the specified endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param originName Name of the origin that is unique within the endpoint.
     * @param origin Origin properties
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, profileName, endpointName, originName, origin, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                originName,
                origin,
                options
            }, createOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new origin within the specified endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param originName Name of the origin that is unique within the endpoint.
     * @param origin Origin properties
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, profileName, endpointName, originName, origin, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, profileName, endpointName, originName, origin, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing origin within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param originName Name of the origin which is unique within the endpoint.
     * @param originUpdateProperties Origin properties
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, profileName, endpointName, originName, originUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                originName,
                originUpdateProperties,
                options
            }, updateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an existing origin within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param originName Name of the origin which is unique within the endpoint.
     * @param originUpdateProperties Origin properties
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, profileName, endpointName, originName, originUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, profileName, endpointName, originName, originUpdateProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing origin within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param originName Name of the origin which is unique within the endpoint.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, endpointName, originName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, profileName, endpointName, originName, options }, deleteOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing origin within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param originName Name of the origin which is unique within the endpoint.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, endpointName, originName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, endpointName, originName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByEndpointNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param nextLink The nextLink from the previous successful call to the ListByEndpoint method.
     * @param options The options parameters.
     */
    _listByEndpointNext(resourceGroupName, profileName, endpointName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, nextLink, options }, listByEndpointNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByEndpointOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/origins",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OriginListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/origins/{originName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Origin
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName,
        originName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/origins/{originName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Origin
        },
        201: {
            bodyMapper: Origin
        },
        202: {
            bodyMapper: Origin
        },
        204: {
            bodyMapper: Origin
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: origin1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName,
        originName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/origins/{originName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Origin
        },
        201: {
            bodyMapper: Origin
        },
        202: {
            bodyMapper: Origin
        },
        204: {
            bodyMapper: Origin
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: originUpdateProperties1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName,
        originName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/origins/{originName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName,
        originName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByEndpointNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OriginListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing OriginGroups operations. */
class OriginGroupsImpl {
    /**
     * Initialize a new instance of the class OriginGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the existing origin groups within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    listByEndpoint(resourceGroupName, profileName, endpointName, options) {
        const iter = this.listByEndpointPagingAll(resourceGroupName, profileName, endpointName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByEndpointPagingPage(resourceGroupName, profileName, endpointName, options, settings);
            }
        };
    }
    listByEndpointPagingPage(resourceGroupName, profileName, endpointName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByEndpointPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByEndpoint(resourceGroupName, profileName, endpointName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByEndpointNext(resourceGroupName, profileName, endpointName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByEndpointPagingAll(resourceGroupName, profileName, endpointName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByEndpointPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByEndpointPagingPage(resourceGroupName, profileName, endpointName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the existing origin groups within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    _listByEndpoint(resourceGroupName, profileName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, options }, listByEndpointOperationSpec$1);
    }
    /**
     * Gets an existing origin group within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param originGroupName Name of the origin group which is unique within the endpoint.
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, endpointName, originGroupName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            profileName,
            endpointName,
            originGroupName,
            options
        }, getOperationSpec$2);
    }
    /**
     * Creates a new origin group within the specified endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param originGroupName Name of the origin group which is unique within the endpoint.
     * @param originGroup Origin group properties
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, profileName, endpointName, originGroupName, originGroup, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                originGroupName,
                originGroup,
                options
            }, createOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new origin group within the specified endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param originGroupName Name of the origin group which is unique within the endpoint.
     * @param originGroup Origin group properties
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, profileName, endpointName, originGroupName, originGroup, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, profileName, endpointName, originGroupName, originGroup, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing origin group within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param originGroupName Name of the origin group which is unique within the endpoint.
     * @param originGroupUpdateProperties Origin group properties
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, profileName, endpointName, originGroupName, originGroupUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                originGroupName,
                originGroupUpdateProperties,
                options
            }, updateOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an existing origin group within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param originGroupName Name of the origin group which is unique within the endpoint.
     * @param originGroupUpdateProperties Origin group properties
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, profileName, endpointName, originGroupName, originGroupUpdateProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, profileName, endpointName, originGroupName, originGroupUpdateProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing origin group within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param originGroupName Name of the origin group which is unique within the endpoint.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, endpointName, originGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                originGroupName,
                options
            }, deleteOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing origin group within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param originGroupName Name of the origin group which is unique within the endpoint.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, endpointName, originGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, endpointName, originGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByEndpointNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param nextLink The nextLink from the previous successful call to the ListByEndpoint method.
     * @param options The options parameters.
     */
    _listByEndpointNext(resourceGroupName, profileName, endpointName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, nextLink, options }, listByEndpointNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByEndpointOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/originGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OriginGroupListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/originGroups/{originGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OriginGroup
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName,
        originGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/originGroups/{originGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: OriginGroup
        },
        201: {
            bodyMapper: OriginGroup
        },
        202: {
            bodyMapper: OriginGroup
        },
        204: {
            bodyMapper: OriginGroup
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: originGroup1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName,
        originGroupName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$7
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/originGroups/{originGroupName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: OriginGroup
        },
        201: {
            bodyMapper: OriginGroup
        },
        202: {
            bodyMapper: OriginGroup
        },
        204: {
            bodyMapper: OriginGroup
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: originGroupUpdateProperties1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName,
        originGroupName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$7
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/originGroups/{originGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName,
        originGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listByEndpointNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OriginGroupListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CustomDomains operations. */
class CustomDomainsImpl {
    /**
     * Initialize a new instance of the class CustomDomains class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the existing custom domains within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    listByEndpoint(resourceGroupName, profileName, endpointName, options) {
        const iter = this.listByEndpointPagingAll(resourceGroupName, profileName, endpointName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByEndpointPagingPage(resourceGroupName, profileName, endpointName, options, settings);
            }
        };
    }
    listByEndpointPagingPage(resourceGroupName, profileName, endpointName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByEndpointPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByEndpoint(resourceGroupName, profileName, endpointName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByEndpointNext(resourceGroupName, profileName, endpointName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByEndpointPagingAll(resourceGroupName, profileName, endpointName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByEndpointPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByEndpointPagingPage(resourceGroupName, profileName, endpointName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the existing custom domains within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param options The options parameters.
     */
    _listByEndpoint(resourceGroupName, profileName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, options }, listByEndpointOperationSpec);
    }
    /**
     * Gets an existing custom domain within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param customDomainName Name of the custom domain within an endpoint.
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, endpointName, customDomainName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            profileName,
            endpointName,
            customDomainName,
            options
        }, getOperationSpec$1);
    }
    /**
     * Creates a new custom domain within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param customDomainName Name of the custom domain within an endpoint.
     * @param customDomainProperties Properties required to create a new custom domain.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, profileName, endpointName, customDomainName, customDomainProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                customDomainName,
                customDomainProperties,
                options
            }, createOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new custom domain within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param customDomainName Name of the custom domain within an endpoint.
     * @param customDomainProperties Properties required to create a new custom domain.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, profileName, endpointName, customDomainName, customDomainProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, profileName, endpointName, customDomainName, customDomainProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing custom domain within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param customDomainName Name of the custom domain within an endpoint.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, endpointName, customDomainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                customDomainName,
                options
            }, deleteOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing custom domain within an endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param customDomainName Name of the custom domain within an endpoint.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, endpointName, customDomainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, endpointName, customDomainName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Disable https delivery of the custom domain.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param customDomainName Name of the custom domain within an endpoint.
     * @param options The options parameters.
     */
    beginDisableCustomHttps(resourceGroupName, profileName, endpointName, customDomainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                customDomainName,
                options
            }, disableCustomHttpsOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Disable https delivery of the custom domain.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param customDomainName Name of the custom domain within an endpoint.
     * @param options The options parameters.
     */
    beginDisableCustomHttpsAndWait(resourceGroupName, profileName, endpointName, customDomainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDisableCustomHttps(resourceGroupName, profileName, endpointName, customDomainName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Enable https delivery of the custom domain.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param customDomainName Name of the custom domain within an endpoint.
     * @param options The options parameters.
     */
    beginEnableCustomHttps(resourceGroupName, profileName, endpointName, customDomainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            // #region Added default values to add backwards compatibility
            let newOptions = options ? options : {};
            if (!newOptions.customDomainHttpsParameters) {
                const profile = yield this.client.profiles.get(resourceGroupName, profileName);
                newOptions.customDomainHttpsParameters = getDefaultCustomDomainHttpsParameters(profile);
            }
            options = newOptions;
            // #endregion
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                profileName,
                endpointName,
                customDomainName,
                options
            }, enableCustomHttpsOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Enable https delivery of the custom domain.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param customDomainName Name of the custom domain within an endpoint.
     * @param options The options parameters.
     */
    beginEnableCustomHttpsAndWait(resourceGroupName, profileName, endpointName, customDomainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginEnableCustomHttps(resourceGroupName, profileName, endpointName, customDomainName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByEndpointNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param nextLink The nextLink from the previous successful call to the ListByEndpoint method.
     * @param options The options parameters.
     */
    _listByEndpointNext(resourceGroupName, profileName, endpointName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, endpointName, nextLink, options }, listByEndpointNextOperationSpec);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByEndpointOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/customDomains",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomDomainListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/customDomains/{customDomainName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomDomain
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        customDomainName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/customDomains/{customDomainName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CustomDomain
        },
        201: {
            bodyMapper: CustomDomain
        },
        202: {
            bodyMapper: CustomDomain
        },
        204: {
            bodyMapper: CustomDomain
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: customDomainProperties1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        customDomainName,
        endpointName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$6
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/customDomains/{customDomainName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        customDomainName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const disableCustomHttpsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/customDomains/{customDomainName}/disableCustomHttps",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CustomDomain
        },
        201: {
            bodyMapper: CustomDomain
        },
        202: {
            bodyMapper: CustomDomain
        },
        204: {
            bodyMapper: CustomDomain
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        customDomainName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const enableCustomHttpsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/customDomains/{customDomainName}/enableCustomHttps",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CustomDomain
        },
        201: {
            bodyMapper: CustomDomain
        },
        202: {
            bodyMapper: CustomDomain
        },
        204: {
            bodyMapper: CustomDomain
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: customDomainHttpsParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        customDomainName,
        endpointName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$6
};
const listByEndpointNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomDomainListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        profileName,
        nextLink,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
// #region Added default values to add backwards compatibility
class SkuNames {
    static get standard_microsoft() { return "Standard_Microsoft"; }
    static get standard_verizon() { return "Standard_Verizon"; }
    static get standard_akamai() { return "Standard_Akamai"; }
}
function getDefaultCustomDomainHttpsParameters(profile) {
    switch (profile.sku.name) {
        case SkuNames.standard_microsoft:
            return {
                certificateSource: "Cdn",
                certificateSourceParameters: {
                    certificateType: "Dedicated",
                    typeName: "CdnCertificateSourceParameters"
                },
                protocolType: "ServerNameIndication"
            };
        case SkuNames.standard_akamai:
            return {
                certificateSource: "Cdn",
                certificateSourceParameters: {
                    certificateType: "Shared",
                    typeName: "CdnCertificateSourceParameters"
                },
                protocolType: "ServerNameIndication"
            };
        case SkuNames.standard_verizon:
            return {
                certificateSource: "Cdn",
                certificateSourceParameters: {
                    certificateType: "Shared",
                    typeName: "CdnCertificateSourceParameters"
                },
                protocolType: "IPBased"
            };
        default:
            return undefined;
    }
}
// #endregion

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ResourceUsageOperations operations. */
class ResourceUsageOperationsImpl {
    /**
     * Initialize a new instance of the class ResourceUsageOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Check the quota and actual usage of the CDN profiles under the given subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Check the quota and actual usage of the CDN profiles under the given subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$4);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Cdn/checkResourceUsage",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ResourceUsageListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceUsageListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available CDN REST API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available CDN REST API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$3);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/providers/Microsoft.Cdn/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationsListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationsListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing EdgeNodes operations. */
class EdgeNodesImpl {
    /**
     * Initialize a new instance of the class EdgeNodes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Edgenodes are the global Point of Presence (POP) locations used to deliver CDN content to end users.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Edgenodes are the global Point of Presence (POP) locations used to deliver CDN content to end users.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/providers/Microsoft.Cdn/edgenodes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EdgenodeResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EdgenodeResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Policies operations. */
class PoliciesImpl {
    /**
     * Initialize a new instance of the class Policies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the protection policies within a resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the protection policies within a resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1);
    }
    /**
     * Retrieve protection policy with specified name within a resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the CdnWebApplicationFirewallPolicy.
     * @param options The options parameters.
     */
    get(resourceGroupName, policyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, policyName, options }, getOperationSpec);
    }
    /**
     * Create or update policy with specified rule set name within a resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the CdnWebApplicationFirewallPolicy.
     * @param cdnWebApplicationFirewallPolicy Policy to be created.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, policyName, cdnWebApplicationFirewallPolicy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                policyName,
                cdnWebApplicationFirewallPolicy,
                options
            }, createOrUpdateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update policy with specified rule set name within a resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the CdnWebApplicationFirewallPolicy.
     * @param cdnWebApplicationFirewallPolicy Policy to be created.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, policyName, cdnWebApplicationFirewallPolicy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, policyName, cdnWebApplicationFirewallPolicy, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update an existing CdnWebApplicationFirewallPolicy with the specified policy name under the
     * specified subscription and resource group
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the CdnWebApplicationFirewallPolicy.
     * @param cdnWebApplicationFirewallPolicyPatchParameters CdnWebApplicationFirewallPolicy parameters to
     *                                                       be patched.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, policyName, cdnWebApplicationFirewallPolicyPatchParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                policyName,
                cdnWebApplicationFirewallPolicyPatchParameters,
                options
            }, updateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update an existing CdnWebApplicationFirewallPolicy with the specified policy name under the
     * specified subscription and resource group
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the CdnWebApplicationFirewallPolicy.
     * @param cdnWebApplicationFirewallPolicyPatchParameters CdnWebApplicationFirewallPolicy parameters to
     *                                                       be patched.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, policyName, cdnWebApplicationFirewallPolicyPatchParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, policyName, cdnWebApplicationFirewallPolicyPatchParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes Policy
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the CdnWebApplicationFirewallPolicy.
     * @param options The options parameters.
     */
    delete(resourceGroupName, policyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, policyName, options }, deleteOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/cdnWebApplicationFirewallPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CdnWebApplicationFirewallPolicyList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName1
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/cdnWebApplicationFirewallPolicies/{policyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CdnWebApplicationFirewallPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName1,
        policyName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/cdnWebApplicationFirewallPolicies/{policyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CdnWebApplicationFirewallPolicy
        },
        201: {
            bodyMapper: CdnWebApplicationFirewallPolicy
        },
        202: {
            bodyMapper: CdnWebApplicationFirewallPolicy
        },
        204: {
            bodyMapper: CdnWebApplicationFirewallPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: cdnWebApplicationFirewallPolicy,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName1,
        policyName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$2
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/cdnWebApplicationFirewallPolicies/{policyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: CdnWebApplicationFirewallPolicy
        },
        201: {
            bodyMapper: CdnWebApplicationFirewallPolicy
        },
        202: {
            bodyMapper: CdnWebApplicationFirewallPolicy
        },
        204: {
            bodyMapper: CdnWebApplicationFirewallPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: cdnWebApplicationFirewallPolicyPatchParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName1,
        policyName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/cdnWebApplicationFirewallPolicies/{policyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName1,
        policyName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CdnWebApplicationFirewallPolicyList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName1
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedRuleSets operations. */
class ManagedRuleSetsImpl {
    /**
     * Initialize a new instance of the class ManagedRuleSets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all available managed rule sets.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all available managed rule sets.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Cdn/cdnWebApplicationFirewallManagedRuleSets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedRuleSetDefinitionList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedRuleSetDefinitionList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class CdnManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the CdnManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId Azure Subscription ID.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-cdn/8.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2021-06-01";
        this.afdProfiles = new AfdProfilesImpl(this);
        this.afdCustomDomains = new AfdCustomDomainsImpl(this);
        this.afdEndpoints = new AfdEndpointsImpl(this);
        this.afdOriginGroups = new AfdOriginGroupsImpl(this);
        this.afdOrigins = new AfdOriginsImpl(this);
        this.routes = new RoutesImpl(this);
        this.ruleSets = new RuleSetsImpl(this);
        this.rules = new RulesImpl(this);
        this.securityPolicies = new SecurityPoliciesImpl(this);
        this.secrets = new SecretsImpl(this);
        this.validate = new ValidateImpl(this);
        this.logAnalytics = new LogAnalyticsImpl(this);
        this.profiles = new ProfilesImpl(this);
        this.endpoints = new EndpointsImpl(this);
        this.origins = new OriginsImpl(this);
        this.originGroups = new OriginGroupsImpl(this);
        this.customDomains = new CustomDomainsImpl(this);
        this.resourceUsageOperations = new ResourceUsageOperationsImpl(this);
        this.operations = new OperationsImpl(this);
        this.edgeNodes = new EdgeNodesImpl(this);
        this.policies = new PoliciesImpl(this);
        this.managedRuleSets = new ManagedRuleSetsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Check the availability of a resource name. This is needed for resources where name is globally
     * unique, such as a afdx endpoint.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param checkEndpointNameAvailabilityInput Input to check.
     * @param options The options parameters.
     */
    checkEndpointNameAvailability(resourceGroupName, checkEndpointNameAvailabilityInput, options) {
        return this.sendOperationRequest({ resourceGroupName, checkEndpointNameAvailabilityInput, options }, checkEndpointNameAvailabilityOperationSpec);
    }
    /**
     * Check the availability of a resource name. This is needed for resources where name is globally
     * unique, such as a CDN endpoint.
     * @param checkNameAvailabilityInput Input to check.
     * @param options The options parameters.
     */
    checkNameAvailability(checkNameAvailabilityInput, options) {
        return this.sendOperationRequest({ checkNameAvailabilityInput, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * Check the availability of a resource name. This is needed for resources where name is globally
     * unique, such as a CDN endpoint.
     * @param checkNameAvailabilityInput Input to check.
     * @param options The options parameters.
     */
    checkNameAvailabilityWithSubscription(checkNameAvailabilityInput, options) {
        return this.sendOperationRequest({ checkNameAvailabilityInput, options }, checkNameAvailabilityWithSubscriptionOperationSpec);
    }
    /**
     * Check if the probe path is a valid path and the file can be accessed. Probe path is the path to a
     * file hosted on the origin server to help accelerate the delivery of dynamic content via the CDN
     * endpoint. This path is relative to the origin path specified in the endpoint configuration.
     * @param validateProbeInput Input to check.
     * @param options The options parameters.
     */
    validateProbe(validateProbeInput, options) {
        return this.sendOperationRequest({ validateProbeInput, options }, validateProbeOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const checkEndpointNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/checkEndpointNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckEndpointNameAvailabilityOutput
        },
        default: {
            bodyMapper: AfdErrorResponse
        }
    },
    requestBody: checkEndpointNameAvailabilityInput,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const checkNameAvailabilityOperationSpec = {
    path: "/providers/Microsoft.Cdn/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityOutput
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: checkNameAvailabilityInput,
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const checkNameAvailabilityWithSubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Cdn/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityOutput
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: checkNameAvailabilityInput,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const validateProbeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Cdn/validateProbe",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ValidateProbeOutput
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: validateProbeInput,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};

exports.CdnManagementClient = CdnManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
